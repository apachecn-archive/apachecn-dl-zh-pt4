<html><head/><body>


    
        <title>Autoencoders</title>
        
        <meta charset="utf-8"/>
    

    
        

                            
                    Autoencoders
                
            
            
                
<p>本章通过解释编码层和解码层之间的关系来介绍自动编码器模型。我们将展示一个属于无监督学习家族的模型。本章还介绍了通常与自动编码器模型相关的损失函数，并将其应用于MNIST数据的降维及其在自动编码器诱导的潜在空间中的可视化。</p>
<p>本章将涵盖以下主题:</p>
<ul>
<li>无监督学习简介</li>
<li>编码和解码层</li>
<li>在降维和可视化中的应用</li>
<li>无监督学习的伦理含义</li>
</ul>
<h1 id="uuid-6b821113-2574-4121-9dc2-4f33ac16225b">无监督学习简介</h1>
<p>随着机器学习在过去几年的发展，我遇到了许多方法来对不同类型的学习进行分类。最近，在加拿大蒙特利尔举行的NeurIPS 2018大会上，Alex Graves博士分享了关于不同类型学习的信息，如图<em>图7.1 </em>所示:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="img/5bee9eca-50c2-4a2f-ad2d-2d7f4dd7de2e.png" style="width:23.50em;height:9.42em;"/></p>
<p>图7.1-不同类型的学习</p>
<p>当有许多学习算法正在被研究和改进时，这种分类的努力在今天是非常有用的。第一行描绘了<em>主动的</em>学习，这意味着在学习算法和数据之间有一种交互的感觉。例如，在对<em>标记的数据</em>进行操作的强化学习和主动学习中，奖励策略可以通知模型将在接下来的迭代中读取什么类型的数据。然而，我们到目前为止所研究的传统监督学习不涉及与数据源的交互，而是假设数据集是固定的，其维度和形状不会改变；这些非交互式方法被称为<em>被动</em>学习。</p>
<p><em>图7.1 </em>中表格的第二列代表一种特殊的学习算法，它要求<em>无标签</em>从数据中学习。其他算法要求您拥有一个包含与标签<img class="fm-editor-equation" src="img/2e108673-48ce-4bf6-886c-961518e1492f.png" style="width:0.58em;height:1.00em;"/>相关联的数据<img class="fm-editor-equation" src="img/52ff04b1-d1b4-4173-846d-eb4fc6caaa71.png" style="width:0.83em;height:0.92em;"/>的数据集；也就是:<img class="fm-editor-equation" src="img/16a7ebb1-2910-4ea4-be45-11490e9bdd33.png" style="width:7.67em;height:1.50em;"/>。然而，无监督算法不需要标签来与数据“做事情”。</p>
<p>你可以把标签想象成一个<strong>老师</strong>。教师告诉学习者<strong> x </strong>对应于<sub> <img class="fm-editor-equation" src="img/35b87990-2cba-4534-a272-8a62f182d1e0.png" style="width:0.67em;height:1.08em;"/> </sub>，学习者试图通过反复试验来学习<sub> <img class="fm-editor-equation" src="img/af098bbe-7b09-4ffa-a98f-1537109b18f5.png" style="width:0.83em;height:0.92em;"/> </sub>和<sub> <img class="fm-editor-equation" src="img/35b87990-2cba-4534-a272-8a62f182d1e0.png" style="width:0.58em;height:1.00em;"/> </sub>之间的关系，调整其<em>信念</em>(参数)，直到它正确为止。然而，如果没有老师，学习者对标签<img class="fm-editor-equation" src="img/4f8dc03e-cf59-479f-89d9-7e277b089165.png" style="width:0.67em;height:1.08em;"/>一无所知，因此会自己学习<em>关于<img class="fm-editor-equation" src="img/cd1d240b-75a4-4b5b-b53e-e6f9147a5425.png" style="width:0.75em;height:0.83em;"/>的一些东西</em>，提供一些界限，并且在从未了解过<img class="fm-editor-equation" src="img/35b87990-2cba-4534-a272-8a62f182d1e0.png" style="width:0.58em;height:1.00em;"/>的情况下形成自己对<img class="fm-editor-equation" src="img/af098bbe-7b09-4ffa-a98f-1537109b18f5.png" style="width:0.83em;height:0.92em;"/>的信念。</p>
<p>在接下来的章节中，我们将学习<strong>无监督学习</strong>，这是一种假设我们拥有的数据在形状或形式上不会改变，并且在学习过程和部署过程中保持一致的学习类型。这些算法是由标签以外的东西引导的，例如，用于数据压缩的唯一损失函数。另一方面，还有其他算法具有探索机制或特定动机，以交互方式从数据中学习，这些算法是<strong>主动学习</strong>算法。我们不会在这本书里讨论这些算法，因为这本书是为初学者准备的入门书籍。然而，我们将详细讨论一些最健壮的<em>无监督的</em>深度学习模型。</p>
<p>我们将从学习<strong>自动编码器</strong>开始。自动编码器的唯一目的是将输入数据输入由两部分组成的神经网络:一个<strong>编码器</strong>和一个<strong>解码器</strong>。编码器部分的任务是通常将输入数据编码到低维空间中，从而压缩或编码输入数据。模型的解码器部分负责获取输入数据的编码(或压缩)潜在表示，然后在不丢失任何数据的情况下将其重建回其原始形状和原始值。也就是说，在理想的自动编码器中，输入等于输出。让我们在接下来的部分中更详细地讨论这一点。</p>
<h1 id="uuid-d5e80d0a-f432-40ce-b7a1-adf060c83d41">编码和解码层</h1>
<p>自动编码器可以分为两个主要组件，在无监督学习过程中用于特定目的。<em>图7.2 </em>的左侧显示了使用全连接(密集)层实现的自动编码器。它接收某个向量<img src="img/51804466-39c7-495b-a3c7-6b5a0e8462fe.png" style="width:3.92em;height:1.42em;"/>作为输入，然后进入六个隐藏层；前三个分别具有6、4和2个神经元，意在将输入数据压缩到二维，因为两个神经元的输出是两个标量值。这第一组层被称为<strong>编码器</strong>:</p>
<div><img src="img/f308db9c-1cf1-42e1-b1eb-7c8bfea595b9.png"/></div>
<p>图7.2–自动编码器的两种表示。左图:完整的描述性模型。右图:紧凑和抽象的模型表示</p>
<p>第二组神经元旨在使用分别具有4、6和8个神经元的三层将输入数据重建回其原始维度和值<img src="img/9d520487-cfc5-48c1-aa44-2e0a69486ce5.png" style="width:3.00em;height:1.08em;"/>;这组层被称为<strong>解码器</strong>。</p>
<p>注意，自动编码器的最后一层<em>必须有</em>与输入向量维数相同的神经元。否则，重建将与输入数据不匹配。</p>
<p>在这种情况下，图7.2 左侧<em>所示的自动编码器充当压缩网络，在训练模型以实现良好重建后，如果我们断开解码器，我们最终会得到一个将输入数据编码为二维(或我们选择的任何维度)的神经网络。这提供了优于监督模型的独特优势:在监督模型中，我们教导网络寻找允许与给定目标标签关联的模式；然而，在无监督学习中(或者例如在该自动编码器中)，网络不寻找特定的模式，而是学习以任何方式使用输入空间，以保留输入数据的最有代表性和最重要的信息，从而允许在解码器中进行良好的重建。</em></p>
<p>想象一个神经网络和一个自动编码器，它获取猫和狗的输入图像；传统的神经网络可以被训练来区分狗和猫，它的任务是在狗和猫的图像中找到重要的模式，以便区分它们之间的差异；然而，自动编码器将训练学习最重要的模式，所有模式中最具代表性的模式，以便保存该信息并允许良好的重建，而不管标签如何。在某种程度上，传统的监督神经网络偏向于用猫和狗来看世界，而autoencoder不管猫还是狗都可以自由地从世界中学习。</p>
<p><em>图7.2 </em>右侧的图表描述了更抽象、更紧凑的自动编码器的替代表示。当描述一个相对较深的自动编码器时，这种类型的表示是有用的，当层数大到难以一个接一个地表示所有的神经元和所有的层时(如在图7.2 的左侧)。我们将使用这些梯形来表示有一个编码器/解码器；我们还注意到，这种抽象将允许我们自由地使用其他类型的层，而不仅仅是密集(完全连接的)层。<em>图7.2的右图</em>描绘了一个自动编码器，它将一幅图像作为输入，然后将输入编码到一个<em> d- </em>维空间，然后将<em>潜在</em>向量重构回输入(图像)空间。</p>
<p><strong>潜在空间<em> </em> </strong>是映射学习到的低维模式的空间。它也被称为<em>学习表示空间</em>。理想情况下，该潜在空间富含关于输入数据的重要信息，并且比输入数据具有更少的维度，而没有任何信息损失。</p>
<p>现在，让我们根据<em>图7.2 </em>左侧的简单模型来实现每个自动编码器部分。</p>
<h2 id="uuid-e9b7133d-4086-4544-b0d5-f1f7f2149cff" class="mce-root">编码层</h2>
<p>我们将使用的TensorFlow和Keras库是来自<kbd>tensorflow.keras.layers</kbd>的<kbd>Input</kbd>和<kbd>Dense</kbd>以及来自<kbd>tensorflow.keras.models</kbd>的<kbd>Model</kbd>。我们将使用<kbd>keras</kbd>功能方法，而不是<em>顺序</em>建模。导入以下内容:</p>
<pre>from tensorflow.keras.layers import Input, Dense<br/>from tensorflow.keras.models import Model</pre>
<p><kbd>Input</kbd>层将用于描述输入向量的维度，在我们的例子中是<kbd>8</kbd>:</p>
<pre>inpt_dim = 8<br/>ltnt_dim = 2 <br/><br/>inpt_vec = Input(shape=(inpt_dim,))</pre>
<p>然后，考虑我们所有的激活函数为<kbd>sigmoid</kbd>，仅仅为了这个例子，我们可以如下定义编码器层的流水线:</p>
<pre>elayer1 = Dense(6, activation='sigmoid')(inpt_vec)<br/>elayer2 = Dense(4, activation='sigmoid') (elayer1)<br/>encoder = Dense(ltnt_dim, activation='sigmoid') (elayer2)</pre>
<p><kbd>Dense</kbd>类构造器接收神经元的数量和激活函数作为参数，在定义的末尾(在右侧)，我们必须包括层的输入是什么，这在左侧被分配了一个名称。因此，在第<kbd>elayer1 = Dense(6, activation='sigmoid')(inpt_vec)</kbd>行中，分配给该层的名称是<kbd>elayer1</kbd>，那么<kbd>6</kbd>是神经元的数量，<kbd>activation='sigmoid'</kbd>给密集层分配一个<kbd>sigmoid</kbd>激活函数，<kbd>inpt_vec</kbd>是流水线中该层的输入。</p>
<p class="mce-root"/>
<p>在前面的三行代码中，我们已经定义了编码器的层，如果我们将它做成一个模型并对其调用<kbd>predict()</kbd>,<kbd>encoder</kbd>变量指向可以输出潜在变量的对象:</p>
<pre>latent_ncdr = Model(inpt_vec, encoder)</pre>
<p>在这一行代码中，<kbd>latent_ncdr</kbd>包含的模型一旦被训练，就可以将输入数据映射到潜在空间。但在此之前，我们先以类似的方式定义解码器的各层。</p>
<h2 id="uuid-f7815cc2-14f4-4776-859c-09a9a7edfc68">解码层</h2>
<p>我们可以将解码器层定义如下:</p>
<pre>dlayer1 = Dense(4, activation='sigmoid')(encoder)<br/>dlayer2 = Dense(6, activation='sigmoid') (dlayer1)<br/>decoder = Dense(inpt_dim, activation='sigmoid') (dlayer2)</pre>
<p>请注意，在前面的代码中，神经元的数量通常以递增的顺序排列，直到最后一层与输入维度匹配。在这种情况下，4、6和8被定义为<kbd>inpt_dim</kbd>。类似地，<kbd>decoder</kbd>变量指向可以输出重构输入的对象，如果我们把它做成一个模型并在其上调用<kbd>predict()</kbd>。</p>
<p>我们在这里有意将编码器和解码器分开，只是为了表明，如果我们选择这样做，我们可以有能力访问网络的不同组件。然而，我们可能也应该定义自动编码器作为一个整体，从输入到输出，通过使用如下的<kbd>Model</kbd>类:</p>
<pre>autoencoder = Model(inpt_vec, decoder)</pre>
<p>这正是我们之前所说的“如果我们把它做成一个模型，并在其上调用<kbd>predict()</kbd>”的意思该声明创建了一个模型，该模型将在<kbd>inpt_vec</kbd>中定义的输入向量作为输入，并从<kbd>decoder</kbd>层检索输出。然后，我们可以使用它作为一个模型对象，Keras中有一些很好的函数，允许我们传递输入、读取输出、训练和做其他事情，我们将在接下来的部分中讨论。现在，既然我们已经定义了我们的模型，在我们可以训练它之前，我们应该定义训练的目标是什么，即<em>，</em>我们的损失函数将是什么。</p>
<p class="mce-root"/>
<h2 id="uuid-501196b4-928d-48f2-aa13-c81e8498c0ff">损失函数</h2>
<p>我们的损失函数必须符合自动编码器的目标。这个目标是完美地重建输入。这意味着在理想的自动编码器中，我们的输入<img src="img/5609bfb0-1712-46de-89cc-f6748f485e75.png" style="width:3.17em;height:1.17em;"/>和重构<img class="fm-editor-equation" src="img/20073a1c-ab85-4c68-9710-7dc75e3838d9.png" style="width:3.25em;height:1.17em;"/>必须相同。这意味着绝对差值必须为零:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="img/46e56da7-bf75-4217-8bda-4ebfce996ffa.png" style="width:6.08em;height:1.42em;"/></p>
<p>然而，这可能是不现实的，并且它不是在一个我们可以容易地区分的功能方面。为此，我们可以回到经典的均方误差函数，其定义如下:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="img/c7136505-52c9-429a-8d05-5d958e6983f1.png" style="width:9.42em;height:3.17em;"/></p>
<p class="mce-root">我们想让<img class="fm-editor-equation" src="img/cf4788bf-0dbb-4180-9e74-0c6f8c31b7b0.png" style="width:2.42em;height:0.83em;"/>，理想状态下，或者充其量是尽可能的最小化。我们将该损失函数解释为最小化输入与其重构之间的平方差的平均值。如果我们使用标准的反向投影策略，比如说某种类型的标准梯度下降技术，我们可以编译<em> </em>该模型，并为训练做如下准备:</p>
<div><pre>autoencoder.compile(loss='mean_squared_error', optimizer='sgd')</pre></div>
<p><kbd>compile()</kbd>方法为训练准备模型。前面定义的损失函数作为参数<kbd>loss='mean_squared_error'</kbd>给出，这里选择的优化技术称为<strong>随机梯度下降</strong> ( <strong> SGD </strong> ) <em>，</em> <kbd>optimizer='sgd'</kbd>。有关SGD的更多信息，请参见Amari，S. I. (1993)。</p>
<h2 id="uuid-12f2ba74-7960-4ed7-877d-56ca333b75c2">学习和测试</h2>
<p>由于这是一个简单的自动编码器的介绍性示例，我们将只使用一个数据点进行训练，并开始学习过程。我们还想显示编码版本和重构版本。</p>
<p>我们将二进制中的数字39作为八位数，对应00100111。我们将它声明为我们的输入向量，如下所示:</p>
<pre>import numpy as np<br/>x = np.array([[0., 0., 1., 0., 0., 1., 1., 1.]])</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>然后，我们可以按如下方式进行培训:</p>
<pre>hist = autoencoder.fit(x, x, epochs=10000, verbose=0)<br/><br/>encdd = latent_ncdr.predict(x)<br/>x_hat = autoencoder.predict(x)</pre>
<p><kbd>fit()</kbd>方法执行训练。它的前两个参数是输入数据和期望的目标输出；对于自动编码器，它们都是<kbd>x</kbd>。时期的数量被指定为<kbd>epochs=10000</kbd>，因为模型在这一点上可以产生一个不错的输出，我们将详细度设置为零，因为我们不需要使用<kbd>verbose=0</kbd>来可视化每个时期。</p>
<p>在Google Colab或Jupyter Notebook中，一次在屏幕上可视化1000多个纪元并不是一个好主意。web浏览器可能对负责显示所有这些时期的JavaScript代码没有反应。当心。</p>
<p>潜在编码器模型<kbd>latent_ncdr</kbd>和<kbd>autoencoder</kbd>中的<kbd>predict()</kbd>方法在指定层产生输出。如果我们检索<kbd>encdd</kbd>，我们可以看到输入的潜在表示，如果我们检索<kbd>x_hat</kbd>，我们可以看到重建。我们甚至可以手动计算均方差，如下所示:</p>
<pre>print(encdd)<br/>print(x_hat)<br/>print(np.mean(np.square(x-x_hat)))  # MSE</pre>
<p>这会产生以下输出:</p>
<pre>[[0.54846555 0.4299447 ]]<br/>[[0.07678119 0.07935049 0.91219556 0.07693048 0.07255505 0.9112366 0.9168126 0.9168152 ]]<br/>0.0066003498745448655</pre>
<p>由于学习算法的无监督性质，这里的数字会有所不同。第一个输出向量可以是任何实数。第二个输出向量可能具有接近0和接近1的实数，类似于原始的二进制向量，但是确切的值每次都会变化。</p>
<p>两个元素的第一个向量是潜在表示，[0.55，0.43]；在这一点上，这可能对我们来说意义不大，但在数据压缩方面，这将是非常重要的。这意味着我们能够用两位数来表示八位数。</p>
<p>虽然这是一个玩具示例，用两位数表示二进制数并不令人兴奋，但其背后的理论是，我们可以在[0，1]范围内取任意八个浮点数字，并将其压缩为同一范围内的两位数。</p>
<p>显示的第二个向量显示了良好重建的证据:应该是0的东西是0.08，应该是1的东西是0.91。手动计算的<strong>均方误差</strong> ( <strong> MSE </strong>)为0.007，虽然不为零，但也足够小。</p>
<p>我们可以使用存储在调用<kbd>fit()</kbd>期间定义的<kbd>hist</kbd>对象中的信息来可视化整个训练阶段中MSE的衰减。该对象包含跨时期的损失函数值的信息，并允许我们使用以下代码来可视化该过程:</p>
<pre>import matplotlib.pyplot as plt<br/><br/>plt.plot(<strong>hist.history['loss']</strong>)<br/>plt.title('Model reconstruction loss')<br/>plt.ylabel('MSE')<br/>plt.xlabel('Epoch')<br/>plt.show()</pre>
<p>这将产生您在图7.3 中看到的内容:</p>
<div><img src="img/2207d736-a57d-4b78-b766-5d47cdb5e6b3.png" style="width:35.00em;height:22.00em;"/></div>
<p>图7.3–根据MSE描述的自动编码器训练各时期的重建损失</p>
<p>好的，再一次，这是一个只有一个数据点的玩具例子。在现实生活中，我们永远不会这样做。为了显示这是一个多么糟糕的想法，我们可以使用我们用来训练模型的二进制字符串，并反转每一位，从而得到11011000(或十进制的216)。如果我们把这个交给自动编码器，我们会期待一个好的重建，但是让我们看看如果我们尝试这样做会发生什么:</p>
<pre>x = np.array([[1., 1., 0., 1., 1., 0., 0., 0.]])  #216<br/><br/>encdd = latent_ncdr.predict(x)<br/>x_hat = autoencoder.predict(x)<br/><br/>print(encdd)<br/>print(x_hat)<br/>print(np.mean(np.square(x-x_hat)))</pre>
<p>我们得到以下输出:</p>
<pre>[[0.51493704 0.43615338]]<br/>[[0.07677279 0.07933337 0.9122421 0.07690183 0.07254466 0.9112378 0.9167745 0.91684484]]<br/>0.8444848864148122</pre>
<p>同样，由于学习算法的无监督性质，这里的数字会有所不同。如果你的结果和你在这里看到的不一样(我肯定是)，那不是问题。</p>
<p>如果您将这些结果与之前的结果进行比较，您会注意到潜在的表示并没有太大的不同，并且重构的输出与给定的输入完全不匹配。很明显，模型<strong>记住了它被训练的输入。当我们计算MSE时，这是很明显的，我们得到的值是0.84，与之前得到的值相比是很大的。</strong></p>
<p>当然，解决这个问题的方法是添加更多的数据。但是构建自动编码器的玩具示例到此结束。这之后真正改变的是数据的类型和数量，图层的数量，图层的类型。在下一节中，我们将看看一个简单的自动编码器在降维问题中的应用。</p>
<p class="mce-root"/>
<h1 id="uuid-f147302c-aed7-4207-bfb8-930a920e0e6b">在降维和可视化中的应用</h1>
<p>自动编码器最有趣的应用之一是降维[Wang，y .，et al. (2016)]。鉴于我们生活在一个数据存储容易访问且负担得起的时代，大量数据目前存储在任何地方。然而，并非所有信息都是相关信息。例如，考虑一个总是面向一个方向的家庭安全摄像机的视频记录数据库。很可能在每个视频帧或图像中都有大量重复的数据，而收集到的数据中很少是有用的。我们需要一种策略来观察这些图像中真正重要的东西。图像本质上具有大量冗余信息，并且图像区域之间通常存在相关性，这使得自动编码器在压缩图像中的信息时非常有用(Petscharnig，s .，et al. (2017))。</p>
<p>为了证明自动编码器在图像降维中的适用性，我们将使用众所周知的MNIST数据集。</p>
<h2 id="uuid-767a34b1-e9dd-490f-8029-437cba60a541">MNIST数据准备</h2>
<p>有关MNIST的详细信息，请参见第3章、<em>准备数据</em>。这里我们将只提到MNIST数据将被缩放到范围[0，1]。我们还需要通过将28×28位的图像整形为784维的向量来将所有的图像转换为向量。这可以通过以下方式实现:</p>
<pre>from tensorflow.keras.datasets import mnist<br/><br/>(x_train, y_train), (x_test, y_test) = mnist.load_data()<br/><br/>x_train = x_train.astype('float32') / 255.<br/>x_test = x_test.astype('float32') / 255.<br/><br/>x_train = x_train.reshape((len(x_train), 28*28))<br/>x_test = x_test.reshape((len(x_test), 28*28))</pre>
<p>我们将使用<kbd>x_train</kbd>来训练自动编码器，使用<kbd>x_test</kbd>来测试自动编码器编码和解码MNIST数字的泛化能力。出于可视化的目的，我们将需要<kbd>y_test</kbd>，但是<kbd>y_train</kbd>可以忽略，因为在无监督的机器学习中我们不需要标签。</p>
<p class="mce-root"/>
<p><em>图7.4 </em>描绘了<kbd>x_test</kbd>中的前八个样本。这些样本将在一些实验中使用，以展示不同自动编码器模型的功能:</p>
<div><img src="img/6d1cc115-5ef0-473a-a4a5-f470dc712f1f.png" style="width:15.67em;height:8.08em;"/></div>
<p>图7.4–用于比较的测试MNIST数字</p>
<h2 id="uuid-6a715b45-e8af-40ed-97d1-6d62ab3d493e">MNIST自动编码器</h2>
<p>我们可以设计几个不同层数的实验，看看自动编码器如何为MNIST改变其性能。我们可以从一个具有四层的自动编码器开始，总是使用两个潜在维度。这样做是为了便于在由自动编码器引起的二维空间中可视化MNIST数字。</p>
<p>基于前面定义的自动编码器，我们可以提出以下四层基本自动编码器:</p>
<pre>inpt_dim = 28*28<br/>ltnt_dim = 2<br/><br/>inpt_vec = Input(shape=(inpt_dim,))<br/><br/>elayer1 = Dense(392, activation='sigmoid')(inpt_vec)<br/>elayer2 = Dense(28, activation='sigmoid') (elayer1)<br/>elayer3 = Dense(10, activation='sigmoid') (elayer2)<br/>encoder = Dense(ltnt_dim, activation='<strong>tanh</strong>')(elayer3)<br/><br/>dlayer1 = Dense(10, activation='sigmoid')(encoder)<br/>dlayer2 = Dense(28, activation='sigmoid')(dlayer1)<br/>dlayer3 = Dense(392, activation='sigmoid')(dlayer2)<br/>decoder = Dense(inpt_dim, activation='sigmoid')(dlayer3)<br/><br/>latent_ncdr = Model(inpt_vec, encoder)<br/>autoencoder = Model(inpt_vec, decoder)<br/><br/>autoencoder.compile(loss='<strong>binary_crossentropy</strong>', optimizer='<strong>adam</strong>')<br/><br/>hist = autoencoder.fit(x_train, x_train, epochs=100, batch_size=256, <br/>                       <strong>shuffle=True, validation_data=(x_test, x_test)</strong>)</pre>
<p>这将是后续模型的基础。有几个突出显示的内容是新的，需要正确介绍。第一个重要的东西是一个新的激活函数，叫做<strong>双曲正切</strong>。该激活功能定义如下:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="img/52343b1b-860d-4414-b38c-dcd47901d881.png" style="width:12.92em;height:2.50em;"/></p>
<p>相应的一阶导数相对简单:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="img/787eef00-1a67-4308-a579-98b187cf7ab2.png" style="width:21.58em;height:2.50em;"/></p>
<p>除了具有良好且易于计算的导数之外，双曲正切激活函数还具有良好的输出范围[-1，1]。这允许一个中性范围，不必局限于sigmoid范围[0，1]。出于可视化的目的，有时在双曲正切范围内进行可视化是很有趣的，但没有必要这样做。</p>
<p>我们引入的另一个新元素是称为<strong>二元交叉熵</strong>的损失函数:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="img/b277ace3-8e19-46d5-969d-3c8eb2469cac.png" style="width:23.92em;height:3.17em;"/></p>
<p>一般来说，二进制交叉熵使用信息，这些信息是计算目标数据<img class="fm-editor-equation" src="img/64dc5f89-e650-4e23-a54d-ee7b42d906f2.png" style="width:0.75em;height:0.83em;"/>和重建(或预测)数据<img class="fm-editor-equation" src="img/491f7fd1-ce72-4085-a1f5-9de08fee77d6.png" style="width:0.75em;height:1.08em;"/>之间的误差的理论思想。在某种程度上，它测量了目标和预测之间的熵值，或者说是惊奇值。例如，在理想的自动编码器中，目标<img class="fm-editor-equation" src="img/d759bd24-540c-47ec-a39e-533ee26397b9.png" style="width:0.67em;height:0.75em;"/>等于其重建<img class="fm-editor-equation" src="img/1383cd76-dc04-4c7e-8437-9e74de440010.png" style="width:0.67em;height:1.00em;"/>并不奇怪，损耗应该为零。然而，如果目标<img class="fm-editor-equation" src="img/131b4632-5c63-4ab0-856c-21ef58000492.png" style="width:0.67em;height:0.75em;"/>不等于<img class="fm-editor-equation" src="img/c67111eb-15ba-4682-9dae-c6468ad25fe8.png" style="width:0.75em;height:1.08em;"/>，那将是令人惊讶的，并且会产生高损失。</p>
<p>关于使用交叉熵损失的自动编码器的更完整的讨论，参见(Creswell，a .艾尔。(2017)).</p>
<p>还引入了一个名为<strong> Adam </strong>的新优化器。艾尔。(2014)).它是一种随机优化算法，使用自适应学习速率，在一些深度学习应用中已被证明非常快。当我们处理深度学习模型和大型数据集时，速度是一个很好的属性。时间是至关重要的，亚当提供了一个很好的方法，已经成为流行。</p>
<p class="mce-root"/>
<p>最后，我们添加的最后一个新东西是关于<kbd>fit()</kbd>方法的。你应该注意到有两个新的参数:<kbd>shuffle=True</kbd>，允许在训练过程中进行数据的洗牌；以及<kbd>validation_data=( , )</kbd>，它指定了一个数据元组，用于使用验证数据或模型从未见过且永远不会用于训练的数据来监控损失。</p>
<p>这就是我们介绍的所有新内容。下一步是解释我们将在实验中尝试的自动编码器架构。请参见<em>图7.5 </em>了解我们将要进行的实验参考:</p>
<div><img src="img/9ded95c1-d8fa-45fe-aa65-6c97a457ad43.png"/></div>
<p>图7.5–不同的自动编码器配置展示了潜在表示的质量差异</p>
<p>在图中，您会注意到我们使用了自动编码器的抽象表示，在图7.5 的右侧是每个自动编码器架构将使用的不同层。所示的第一个体系结构对应于本节中所示的代码。也就是说，代码显示了分别具有392、28、10和2个神经元的编码层的自动编码器；而解码层分别包含10、28、392和784个神经元。右边的下一个模型包含相同的层，只是移除了对应于392个神经元的一对层，以此类推。</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>最后一个autoencoder模型只包含两层，一层编码(两个神经元)，一层解码(784个神经元)。此时，您应该能够修改Python代码来删除必要的层，并复制图7.5 中描述的模型。下一步是训练<em>图7.5 </em>中的模型，并可视化输出质量。</p>
<h2 id="uuid-cec91d51-d615-4c89-b3a2-ed6319540256">培训和可视化</h2>
<p>执行100个时期的<kbd>autoencoder.fit()</kbd>产生一个可行的模型，该模型可以容易地编码成指定的二维。在训练期间仔细观察损失函数，我们可以观察到它适当地收敛:</p>
<div><img src="img/1eaad2b2-ec72-436a-a4d6-7551d485dc5a.png"/></div>
<p>图7.6-四层自动编码器训练期间的损失函数监控</p>
<p>一旦模型训练成功，我们就可以使用以下代码检索编码表示:</p>
<pre>encdd = latent_ncdr.predict(x_test)</pre>
<p class="mce-root"/>
<p>我们正在使用测试集<kbd>x_test</kbd>。这种编码将按照规定编码成二维，并且将按照规定产生范围[-1，1]中的潜在表示。类似地，我们总是可以获取测试集，并使用自动编码器对其进行压缩和重构，以查看输入与重构的相似程度。我们是这样做的:</p>
<pre>x_hat = autoencoder.predict(x_test)</pre>
<p>在我们研究从MNIST学到的潜在表征之前，我们可以研究重建质量，作为评估学习模型质量的一种方式。<em>图7.7 </em>显示了使用<em>图7.4 </em>作为提供给每个模型的输入的参考的重建结果(在<kbd>x_hat</kbd>)。该图分为四个部分，每个部分对应于<em>图7.5 </em>中描述的模型:a)八层模型，b)六层模型，c)四层模型，d)两层模型:</p>
<div><img src="img/ba164838-ce99-4c8b-9915-f1d7c9312e19.png" style="width:12.25em;height:24.00em;"/></div>
<p>图7.7–图7.5中模型的自动编码器重建:a)八层模型，b)六层模型，c)四层模型，d)两层模型</p>
<p>从<em>图7.7.a </em>中，我们可以看到具有八层(392、28、10、2、10、28、392、784)的模型能够产生除了数字4和9之外的一般良好的重建。很明显，这两个数字紧密相关(视觉上),自动编码器很难清楚地区分这两个数字。为了进一步探索这种观察，我们可以将潜在空间中的测试数据可视化(在<kbd>encdd</kbd>中)，如图<em>图7.8 </em>所示:</p>
<p class="mce-root"/>
<div><img src="img/0d99e2d5-f02f-416d-bd0a-38ec29e7ef4d.png" style="width:32.75em;height:28.17em;"/></div>
<p>图7.8–使用MNIST测试数据的四层编码器</p>
<p>在自动编码器产生的潜在空间中，数字4和9之间的重叠是明显的。然而，大多数其他数字组都有相对清晰的独立簇。<em>图7.8 </em>也解释了其他看起来很像的数字的自然接近度；例如，一和七看起来很接近，零和六也是如此，三和八也是如此。然而，看起来不一样的数字位于潜在空间的相反部分——例如，0和1。</p>
<p class="mce-root"><em>图7.9 </em>描述了三层自动编码器，去掉了有392个神经元的层，留下了28，10，2个神经元的架构。显然，潜在空间的质量显著降低，尽管一些主要结构是一致的。也就是零和一在相对的两边，其他看起来很像的数字靠得更近；与<em>图7.8 </em>相比，重叠更大。这种三层自动编码器的质量一直较低，如图<em>图7.7.b </em>所示:</p>
<p>图7.9–使用MNIST测试数据的三层编码器</p>
<div><img src="img/4a3f6fa6-12e8-472d-9309-baa2396e9346.png" style="width:38.17em;height:32.83em;"/></div>
<p>在<em>图7.10 </em>中，我们可以观察到具有10个和2个神经元的两层自动编码器的结果，这也比之前的自动编码器有更大的数字重叠；这在<em>图7.7.c </em>所示的较差重建中也很明显:</p>
<p>图7.10–使用MNIST测试数据的双层编码器</p>
<div><img src="img/b60d2d57-df05-46f3-ac6a-8fbded4dfb34.png" style="width:41.17em;height:35.33em;"/></div>
<p>Figure 7.10 – Two-layer encoder using MNIST test data</p>
<p class="mce-root"/>
<p class="mce-root">最后，<em>图7.11 </em>显示了一层自动编码器的潜在空间。显然，这是个糟糕的主意。请考虑我们要求自动编码器做的事情:我们只要求两个神经元找到一种方法来查看一个数字的整个图像，并找到一种方法(学习权重<sub> <img class="fm-editor-equation" src="img/e2c8f2cb-9a89-4d71-9848-c755d1cd2c58.png" style="width:1.08em;height:0.83em;"/> </sub>)将所有图像映射到二维。这是不可能的。从逻辑上讲，如果我们只有一层，我们至少需要10个神经元来充分模拟MNIST的10个数字中的每一个:</p>
<p>图7.11-使用MNIST测试数据的一层编码器-一个坏主意</p>
<div><img src="img/73bc6359-d02c-4f03-b66e-0f8a11f34068.png" style="width:30.33em;height:25.83em;"/></div>
<p>仔细观察<em>图7.11 </em>还可以清楚地看到，轴的比例略有变化；这可以解释为编码器不能将MNIST的所有数字分成潜在空间的不同区域。在实践中，除非输入空间的维数已经非常低，否则请不要使用具有几层和几个神经元的自动编码器。如本实验所示，自动编码器在深度配置中可能更成功。在下一章学习更多关于深度自动编码器的知识。</p>
<p>Close observation of <em>Figure 7.11</em> also makes it clear that the scale of the axes varies just slightly; this can be interpreted as the encoder not being able to separate into different regions of the latent space all the digits of MNIST. In practice, please do not use autoencoders with a few layers with a few neurons, unless the dimensionality of the input space is already very low. Autoencoders might be more successful in deep configurations, as shown in this experiment. Learn more about deep autoencoders in the next chapter.</p>
<p class="mce-root">无监督学习的伦理含义</p>
<h1 id="uuid-a78b991d-dbd9-4609-9a99-bc87871affad">无监督学习，比如我们到目前为止在探索的autoencoder中看到的情况，并不神奇。它是公认的，有非常严格的已知和预先定义的界限。它不具备在数据限制之外学习新事物的能力。记住，无监督学习是被动的学习，如本章介绍部分所解释的。</h1>
<p>然而，即使是最健壮的无监督学习模型也有与之相关的伦理风险。其中一个主要问题是，当处理异常值或可能包含边缘情况的数据时，它们会造成困难。例如，假设有大量IT招聘数据，包括多年经验、当前薪资和候选人知道的编程语言。如果数据主要包含关于具有相同编程语言经验的候选人的数据，并且只有少数人知道Python，那么那些知道Python语言的候选人可能被放置到可能难以清楚地可视化的边界或区域中，因为模型已经了解到由于Python是不常用的语言，所以它可能在数据压缩、维数减少或数据可视化方面不相关。此外，考虑一下如果5年后，你使用同样的模型会发生什么，尽管有更新的编程语言在5年前的培训中是不知道的。对于可视化或数据压缩应用程序，模型可能会也可能不会正确映射这些信息。</p>
<p>您必须非常小心使用哪些数据来训练自动编码器，并且拥有各种案例对于任何模型的可靠性都非常重要。如果数据中没有足够的多样性，自动编码器将偏向于只从一个输入空间学习。想象一下，你用之前的10个MNIST数字的图像训练一个自动编码器——你不会期望自动编码器在猫的图像上正确执行；这将是一个错误，并可能产生不想要的结果。例如，当使用人的图像时，您必须确保训练数据中有足够的种类和多样性来产生适当的训练和健壮的模型，对于不被认为是训练数据一部分的人的图像，该模型不会执行错误。</p>
<p>摘要</p>
<h1 id="uuid-948ee96a-8166-464c-919d-45e3b96227cc">本章说明了自动编码器是非常简单的模型，可用于编码和解码不同目的的数据，例如数据压缩、数据可视化，以及简单地查找仅保留重要特征的潜在空间。我们证明了神经元的数量和自动编码器的层数对于模型的成功是很重要的。更深(更多层)和更广(更多神经元)的特征通常是好模型的组成部分，即使这会导致训练时间变慢。</h1>
<p>至此，你应该知道从被动学习的角度来看，有监督学习和无监督学习的区别。您还应该能够轻松实现自动编码器的两个基本组件:编码器和解码器。类似地，您应该能够修改autoencoder的体系结构，对其进行微调以获得更好的性能。以我们在本章中讨论的例子为例，您应该能够将自动编码器应用于降维问题或数据可视化问题。此外，当涉及到用于训练无监督学习算法的数据时，您应该考虑与无监督学习算法相关的风险和责任。</p>
<p><a href="6677b8b1-806c-4c39-8c1e-371e83501acf.xhtml">第8章</a>、<em>、</em>将继续介绍更深入、更广泛的自动编码器架构，这些架构将超越我们在本章中介绍的内容。下一章将介绍深度信念网络的概念和这种深度无监督学习的重要性。它将通过介绍深度自动编码器并将其与浅层自动编码器进行对比来解释这些概念。本章还将给出优化神经元数量和层数以最大化性能的重要建议。</p>
<p>问题和答案</p>
<h1 id="uuid-d1f342d2-a625-4bed-891c-20cda902fe03"><strong>过度拟合对自动编码器来说是坏事吗？</strong></h1>
<ol>
<li>实际上，不。你想让自动编码器超负荷！也就是说，您希望它在输出中精确地复制输入数据。然而，有一个警告。与模型的大小相比，数据集必须非常大；否则，数据的记忆将阻止模型推广到看不见的数据。</li>
</ol>
<p style="padding-left: 60px">为什么我们在编码器的最后一层使用了两个神经元？</p>
<ol start="2">
<li>仅用于可视化目的。由两个神经元产生的二维潜在空间使我们能够很容易地将潜在空间中的数据可视化。在下一章中，我们将使用不一定具有二维潜在空间的其它构型。</li>
</ol>
<p style="padding-left: 60px">For visualization purposes only. The two-dimensional latent space produced by the two neurons allows us to easily visualize the data in the latent space. In the next chapter, we will use other configurations that do not necessarily have a two-dimensional latent space.</p>
<p> </p>
<p class="mce-root"><strong>自动编码器又有什么酷的？</strong></p>
<ol start="3">
<li><strong>What is so cool about autoencoders again?</strong></li>
</ol>
<p>它们是简单的神经模型，在没有老师(无人监督)的情况下学习。他们不偏向于学习特定的标签(类)。他们通过迭代观察了解数据世界，旨在了解最具代表性和相关性的特征。它们可以用作特征提取模型，但是我们将在以后的章节中对此进行更多的讨论。</p>
<p style="padding-left: 60px">参考</p>
<h1 id="uuid-25e2eace-7e09-4ab7-af6a-91d25f567835">阿马里，S. I. (1993年)。反向传播和随机梯度下降法。<em>神经计算</em>，5(4-5)，185-196。</h1>
<ul>
<li>王，姚海红，赵，等(2016)。基于自动编码器的降维。<em>神经计算</em>，184，232-242。</li>
<li>Petscharnig，s .，Lux，m .，和Chatzichristofis，S. (2017年)。使用深度学习和自动编码器对图像特征进行降维。第15届基于内容的多媒体索引国际研讨会论文集<em>(第23页)。ACM。</em></li>
<li>Creswell，a .，Arulkumaran，k .，和Bharath，A. A. (2017年)。训练成最小化二进制交叉熵的去噪自动编码器。<em> arXiv预印本</em> arXiv:1708.08487。</li>
<li>金马博士和巴律师(2014年)。亚当:一种随机优化方法。arXiv预印本arXiv:1412.6980。</li>
<li>Kingma, D. P., &amp; Ba, J. (2014). Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980.</li>
</ul>


            

            
        
    


</body></html>