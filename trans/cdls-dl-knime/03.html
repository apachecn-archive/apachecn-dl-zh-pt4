<html><head/><body>





	

		<title>B16391_06_Final_VK_ePUB</title>

		

	

	

		<div><h1 id="_idParaDest-101"><em class="italic"> <a id="_idTextAnchor181"/>第六章:</em>递归神经网络用于需求预测</h1>

			<p>到目前为止，我们已经收集了一些关于两种变体的全连接前馈神经网络的经验:通过将输入样本分配给一组预定义类别中的一个类别来实现分类任务，或者通过自动编码器架构来尝试再现输入向量的形状。在这两种情况下，输出响应仅取决于电流输入矢量的值。在时间<img src="img/Formula_B16391_06_001.png" alt=""/>，输出响应<img src="img/Formula_B16391_06_002.png" alt=""/>取决于并且仅取决于在时间<img src="img/Formula_B16391_06_004.png" alt=""/>的输入向量<img src="img/Formula_B16391_06_003.png" alt=""/>。网络对<img src="img/Formula_B16391_06_005.png" alt=""/>之前发生的事情没有记忆，只根据输入<img src="img/Formula_B16391_06_007.png" alt=""/>产生<img src="img/Formula_B16391_06_006.png" alt=""/>。</p>

			<p>对于<strong class="bold">递归神经网络</strong> ( <strong class="bold"> RNNs </strong>)，我们引入时间成分<img src="img/Formula_B16391_06_008.png" alt=""/>。我们将发现这样的网络，其中在时间<img src="img/Formula_B16391_06_001.png" alt=""/>的输出响应<img src="img/Formula_B16391_06_009.png" alt=""/>取决于当前的输入样本<img src="img/Formula_B16391_06_011.png" alt=""/>，以及先前的输入样本<img src="img/Formula_B16391_06_012.png" alt=""/>、<img src="img/Formula_B16391_06_013.png" alt=""/>、… <img src="img/Formula_B16391_06_014.png" alt=""/>，其中对过去<img src="img/Formula_B16391_06_015.png" alt=""/>样本的网络记忆取决于网络架构。</p>

			<p>我们将首先介绍RNNs的一般概念，然后在一个经典的时间序列分析任务:<strong class="bold">需求预测</strong>的领域中介绍<strong class="bold">长短时记忆</strong> ( <strong class="bold"> LSTM </strong>)的具体概念。然后，我们将展示如何不仅向网络馈送静态向量<img src="img/Formula_B16391_06_016.png" alt=""/>，而且馈送向量序列，例如跨越过去输入信号的<img src="img/Formula_B16391_06_021.png" alt=""/>个样本的<img src="img/Formula_B16391_06_017.png" alt=""/>、<img src="img/Formula_B16391_06_018.png" alt=""/>、<img src="img/Formula_B16391_06_019.png" alt=""/>、… <img src="img/Formula_B16391_06_020.png" alt=""/>。这些建立在训练集上的输入向量(张量)序列用于训练和评估基于LSTM的RNN的实际实现。</p>

			<p>总之，本章将涵盖以下主题:</p>

			<ul>

				<li>RNNs简介</li>

				<li>需求预测问题</li>

				<li>数据准备–创造过去</li>

				<li>建立、训练和部署一个位于LSTM的RNN</li>

			</ul>

			<h1 id="_idParaDest-102"><a id="_idTextAnchor182"/>介绍RNNs</h1>

			<p>让我们从RNNs的<a id="_idIndexMarker484"/>概述开始。</p>

			<p><strong class="bold"> RNNs </strong>是一类神经网络，不能被限制在前馈架构中。</p>

			<p class="callout-heading">重要说明</p>

			<p class="callout">rnn是通过将自动或反向连接(即循环连接)引入前馈神经网络而获得的。</p>

			<p>当引入循环连接时，我们引入时间的概念。这允许rnn考虑环境；也就是说，通过捕捉信号的动态来记住来自过去的输入。</p>

			<p>引入递归连接将神经网络的性质从静态改变为动态，因此适合于分析时间序列。实际上，rnn经常被用于创建涉及时间排序序列的问题的解决方案，例如时间序列分析、语言建模、自由文本生成、自动机器翻译、语音识别、图像字幕以及调查给定信号的时间演变的其他类似问题。</p>

			<h2 id="_idParaDest-103"><a id="_idTextAnchor183"/>递归神经网络</h2>

			<p>如前一节所述，在前馈网络中引入自动或反向连接会将其转换为RNN。例如，让我们考虑在<em class="italic">图6.1 </em>中描述的简单前馈网络，在左边看它的详细表示，在右边看它的紧凑表示:</p>

			<div><div><img src="img/B16391_06_001.jpg" alt="Figure 6.1 – A simple fully connected feedforward network on the left and its more compact matrix-based representation on the right"/>

				</div>

			</div>

			<p class="figure-caption">图6.1–左边是一个简单的全连接馈电<a id="_idTextAnchor184"/>前向网络，右边是其更紧凑的矩阵表示</p>

			<p>图6.1 中<em class="italic">网络的简洁<a id="_idIndexMarker485"/>表示包括一个多维输入<img src="img/Formula_B16391_06_022.png" alt=""/>，一个可能的多维输出<a id="_idTextAnchor185"/><img src="img/Formula_B16391_06_023.png" alt=""/>，一个由包含神经元图标的方框表示的隐藏层，以及从输入到隐藏层的两个权重矩阵<img src="img/Formula_B16391_06_024.png" alt=""/>，以及从隐藏到输出层的两个权重矩阵<img src="img/Formula_B16391_06_025.png" alt=""/>。</em></p>

			<p>现在让我们向这个网络引入一个循环连接，除了原始输入向量<img src="img/Formula_B16391_06_027.png" alt=""/> ( <em class="italic">图6.2 </em>)之外，将输出向量<img src="img/Formula_B16391_06_026.png" alt=""/>反馈回输入层。这种对网络架构的简单改变改变了网络行为。以前，网络实现的功能只是<img src="img/Formula_B16391_06_028.png" alt=""/>，其中<img src="img/Formula_B16391_06_029.png" alt=""/>是输入样本<img src="img/Formula_B16391_06_030.png" alt=""/>呈现给网络的当前时间。现在，由递归网络实现的函数呈现形状<img src="img/Formula_B16391_06_031.png" alt=""/>；也就是说，当前输出取决于当前输入，以及在先前步骤中为先前输入样本产生的输出。我们已经引入了时间的概念:</p>

			<div><div><img src="img/B16391_06_002.jpg" alt="Figure 6.2 – Adding a recurrent connection to the feedforward network"/>

				</div>

			</div>

			<p class="figure-caption">图6.2–将循环连接添加到前馈<a id="_idTextAnchor186"/>网络</p>

			<p>由于这些<a id="_idIndexMarker486"/>循环连接，RNNs的输出也包含输入信号的一点历史。然后我们说他们有记忆。记忆范围延伸到过去多远取决于循环的架构和其中包含的范例。由于这个原因，RNNs比前馈网络更适合分析序列数据，因为它们也可以处理来自过去的信息。过去的输入信息通过递归连接经由输出反馈代谢到输入层。</p>

			<p>现在的问题是如何训练一个输出也依赖于先前输出的网络。可以想象，这些年来已经提出了许多算法。最简单的一种，也是最常被采用的<a id="_idIndexMarker487"/>，是<strong class="bold">穿越时间的反向传播</strong>(<strong class="bold">BPTT</strong>)(good fellow I，Bengio Y .，库维尔a .，<em class="italic">深度学习</em>，麻省理工学院出版社，(2016)。</p>

			<p>BPTT是基于随着时间的推移展开网络的概念。为了理解<em class="italic">展开</em>的概念<a id="_idIndexMarker488"/>，让我们在训练期间<img src="img/Formula_B16391_06_032.png" alt=""/>的不同时间浏览一下网络:</p>

			<ul>

				<li>在<img src="img/Formula_B16391_06_033.png" alt=""/>时刻，我们有<a id="_idIndexMarker489"/>原始前馈网络，带有权重矩阵<img src="img/Formula_B16391_06_034.png" alt=""/>和<img src="img/Formula_B16391_06_035.png" alt=""/>，输入<img src="img/Formula_B16391_06_036.png" alt=""/>和<img src="img/Formula_B16391_06_037.png" alt=""/>，输出<img src="img/Formula_B16391_06_038.png" alt=""/>。</li>

				<li>在时间<img src="img/Formula_B16391_06_039.png" alt=""/>，我们再次具有原始前馈网络，具有权重矩阵<img src="img/Formula_B16391_06_040.png" alt=""/>和<img src="img/Formula_B16391_06_041.png" alt=""/>，但是这次具有输入<img src="img/Formula_B16391_06_042.png" alt=""/>和<img src="img/Formula_B16391_06_043.png" alt=""/>以及输出<img src="img/Formula_B16391_06_044.png" alt=""/>。</li>

				<li>在时间<img src="img/Formula_B16391_06_045.png" alt=""/>，我们再次拥有原始前馈网络，具有权重矩阵<img src="img/Formula_B16391_06_046.png" alt=""/>和<img src="img/Formula_B16391_06_047.png" alt=""/>，但是这次具有输入<img src="img/Formula_B16391_06_048.png" alt=""/>和<img src="img/Formula_B16391_06_049.png" alt=""/>以及输出<img src="img/Formula_B16391_06_050.png" alt=""/>。</li>

				<li>对于输入序列中的<img src="img/Formula_B16391_06_021.png" alt=""/>样本，这将继续。</li>

			</ul>

			<p>实际上，我们<a id="_idIndexMarker490"/>可以用静态权重矩阵<img src="img/Formula_B16391_06_052.png" alt=""/>和<img src="img/Formula_B16391_06_053.png" alt=""/> <img src="img/Formula_B16391_06_054.png" alt=""/>多次复制同一个原始前馈网络，这与输入序列中的<img src="img/Formula_B16391_06_055.png" alt=""/>样本一样多(<em class="italic">图6.3 </em>)。在时间<img src="img/Formula_B16391_06_056.png" alt=""/>原始网络的每个副本将具有当前输入向量<img src="img/Formula_B16391_06_057.png" alt=""/>和先前输出向量<img src="img/Formula_B16391_06_058.png" alt=""/>作为输入。更一般地，在每个时间<img src="img/Formula_B16391_06_059.png" alt=""/>，网络拷贝将产生输出<img src="img/Formula_B16391_06_060.png" alt=""/>和相关状态<img src="img/Formula_B16391_06_061.png" alt=""/>。状态<img src="img/Formula_B16391_06_062.png" alt=""/>是网络存储器，并馈送静态网络的下一个副本，而<img src="img/Formula_B16391_06_063.png" alt=""/>是每个网络副本的专用输出。在一些递归架构中，<img src="img/Formula_B16391_06_064.png" alt=""/>和<img src="img/Formula_B16391_06_065.png" alt=""/>是相同的。</p>

			<p>我们总结一下。我们<a id="_idIndexMarker491"/>有一个具有以下特征的循环网络:</p>

			<ul>

				<li>由<img src="img/Formula_B16391_06_067.png" alt=""/>大小的输入张量<img src="img/Formula_B16391_06_066.png" alt=""/>提供，由一系列<img src="img/Formula_B16391_06_068.png" alt=""/> <img src="img/Formula_B16391_06_069.png" alt=""/>维向量组成</li>

				<li>产生大小为<img src="img/Formula_B16391_06_071.png" alt=""/>的输出张量<img src="img/Formula_B16391_06_070.png" alt=""/>，由一系列<img src="img/Formula_B16391_06_072.png" alt=""/> <img src="img/Formula_B16391_06_073.png" alt=""/>维向量组成</li>

				<li>Producing a state tensor, <img src="img/Formula_B16391_06_074.png" alt=""/>, related to output tensor <img src="img/Formula_B16391_06_075.png" alt=""/>, used as the network memory<p class="callout-heading">重要说明</p><p class="callout">这个循环网络也可能只是一个子网络，是一个更大的神经架构中的隐藏单元。在这种情况下，它由前几层的输出提供，其输出构成了更大网络中下几层的输入。那么，<img src="img/Formula_B16391_06_076.png" alt=""/>就不是全网的输出，而只是这个递归单元的输出——也就是全网的一个中间隐藏状态。</p></li>

			</ul>

			<p>在<em class="italic">图6.3 </em>中，我们<a id="_idIndexMarker492"/>提出了在<em class="italic">图6.2 </em>中简单递归网络的四个时间步上展开:</p>

			<div><div><img src="img/B16391_06_003.jpg" alt="Figure 6.3 – Unrolling a recurrent network though time"/>

				</div>

			</div>

			<p class="figure-caption">图6.3-随着时间的推移展开循环网络</p>

			<p>此时，我们已经将递归子网络转换为原始前馈网络的<img src="img/Formula_B16391_03_173.png" alt=""/>个副本的序列<a id="_idTextAnchor187"/>，也就是说，转换为一个更大的静态前馈网络。尽管它可能很大，但我们确实已经知道如何用反向传播算法训练完全连接的前馈网络。因此，反向传播算法已被修改为包括展开过程，并训练产生的前馈网络。这是基本的BPTT算法。多年来，BPTT算法的许多变体也被提出。</p>

			<p>我们现在将深入研究最简单的循环网络的细节，即仅由一层循环单元构成的网络。</p>

			<h2 id="_idParaDest-104"><a id="_idTextAnchor188"/>递归神经单元</h2>

			<p>最简单的递归神经单元<a id="_idIndexMarker494"/>由一个只有一个隐藏层的网络组成，具有激活功能<img src="img/Formula_B16391_06_078.png" alt=""/>，具有自动连接。使用相同的随时间展开过程，我们可以将该单元表示为仅具有一个单元的一个隐藏层的前馈网络的<img src="img/Formula_B16391_03_252.png" alt=""/>副本(<em class="italic">图6.4 </em>):</p>

			<div><div><img src="img/B16391_06_004.jpg" alt="Figure 6.4 – The simplest recurrent neural unit"/>

				</div>

			</div>

			<p class="figure-caption">图6.4–最简单的递归神经单元</p>

			<p>在这种情况下，<img src="img/Formula_B16391_06_080.png" alt=""/>输出也是网络的状态，它被反馈到<a id="_idTextAnchor189"/> e输入中——也就是在时间<img src="img/Formula_B16391_06_081.png" alt=""/>反馈到展开的网络的下一个副本的输入中。</p>

			<p>这个简单的递归<a id="_idIndexMarker495"/>单元已经显示了一些内存，在某种意义上，当前的输出也依赖于输入层先前呈现的样本。但是，它的架构有点过于简单，无法显示相当大的内存跨度。当然要看任务来解决需要多长的记忆跨度。一个经典的例子是句子补全。</p>

			<p>要完成一个句子，你需要知道句子的主题，而要知道主题，你需要知道句子中的前几个词。例如，分析句子<em class="italic">汽车行驶在……</em>上，我们意识到题目是<em class="italic">汽车</em>，那么唯一符合逻辑的答案将是<em class="italic">路</em>。为了完成这个句子，我们只需要记住四个单词。我们现在来看一个更复杂的句子，比如<em class="italic">我爱海滩。我最喜欢的声音是……</em>的撞击声。在这里，很多答案都是可能的，包括<em class="italic">汽车</em>、<em class="italic">玻璃</em>，或者<em class="italic">波浪</em>。为了理解哪个是逻辑答案，我们需要在句子中回到单词<em class="italic"> beach </em>，向后九个单词。分析这句话所需的记忆广度是分析上一句话所需记忆广度的两倍多。这个简短的例子表明，有时需要更长的记忆跨度来给出正确的答案。</p>

			<p>简单的递归神经单元提供了一些记忆，但通常不足以解决大多数需要的任务。我们需要更强大的东西，可以追溯到更远的过去，而不仅仅是简单的循环单元所能做的。这正是引入LSTM单位的原因。</p>

			<h2 id="_idParaDest-105"><a id="_idTextAnchor190"/>长短期记忆</h2>

			<p>LSTM于1997年首次介绍了<a id="_idIndexMarker496"/>(hoch Reiter，Sepp and Schmidhuber，jürgen(1997)<em class="italic">长短期记忆。神经计算</em>，9。1735-80.10.1162/ neco.1997.9.8.1735，https://www . researchgate . net/publication/13853244 _ Long _ Short-term _ Memory)。它是一种更复杂的递归单元，使用一个额外的隐藏向量、单元状态或存储器状态、<img src="img/Formula_B16391_06_082.png" alt=""/>和门的概念。</p>

			<p><em class="italic">图6.5 </em>展示了一个展开的LSTM单元的结构(C. Olah，<em class="italic">了解LSTM网络</em>，2015，<a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">https://colah.github.io/posts/2015-08-Understanding-LSTMs/</a>):</p>

			<div><div><img src="img/B16391_06_005.jpg" alt="Figure 6.5 – LSTM layer"/>

				</div>

			</div>

			<p class="figure-caption">图6.5-LSTM层</p>

			<p>如你所见，这个单元的不同副本由两个隐藏向量连接。顶部的一个是单元st <a id="_idTextAnchor191"/> ate向量<img src="img/Formula_B16391_06_083.png" alt=""/>，用于使信息通过不同的单元副本。底部的第二个是这个单元的输出向量。</p>

			<p>接下来，我们有大门，总共三个。门可以打开或关闭(或部分打开/关闭)，通过这种<a id="_idIndexMarker497"/>方式，它们决定在隐藏向量中存储或删除什么。门由一个sigmoid函数和一个逐点乘法组成。事实上，sigmoid函数采用[0，1]中的值。具体来说，<img src="img/Formula_B16391_06_084.png" alt=""/>删除输入(忘记它)，而<img src="img/Formula_B16391_06_085.png" alt=""/>让输入不变地通过(记住它)。在<img src="img/Formula_B16391_06_086.png" alt=""/>和<img src="img/Formula_B16391_06_087.png" alt=""/>之间，记忆和遗忘的各种细微差别都是可能的。</p>

			<p>这些实现门的sigmoid层的权重通过学习过程来调整。也就是说，通过进行猜测、反向传播误差和通过梯度下降调整权重的迭代过程，门学习何时允许数据进入、离开或被删除。LSTM层的训练算法也是反向传播算法的改编。</p>

			<p>LSTM层包含三个门:遗忘门、输入门和输出门(<em class="italic">图6.5 </em>)。让我们仔细看看这些门。</p>

			<h3>遗忘之门</h3>

			<p>左起第一个门<strong class="bold">遗忘门</strong>，过滤单元状态向量中的分量。基于当前输入向量<img src="img/Formula_B16391_06_088.png" alt=""/>和前一个单元的输出向量<img src="img/Formula_B16391_06_089.png" alt=""/>中的<a id="_idIndexMarker498"/>值，该门产生一个忘记或记住决定，如下所示:</p>

			<p class="figure-caption"><img src="img/Formula_B16391_06_090.png" alt=""/></p>

			<p>这里，<img src="img/Formula_B16391_06_091.png" alt=""/>是遗忘门的权重矩阵。</p>

			<p>然后，<a id="_idIndexMarker499"/>决定<img src="img/Formula_B16391_06_092.png" alt=""/>的向量逐点乘以隐藏单元状态向量<img src="img/Formula_B16391_06_093.png" alt=""/>，以决定从前一状态记住什么(<img src="img/Formula_B16391_06_094.png" alt=""/>)和忘记什么(<img src="img/Formula_B16391_06_095.png" alt=""/>)。</p>

			<p>现在的问题是，我们为什么要忘记？如果引入LSTM单位是为了获得更长的记忆，为什么我们需要忘记一些东西呢？例如，分析文本语料库中的文档；您可能需要忘记关于前一个文档的所有知识，因为这两个文档可能是不相关的。因此，对于每个新文档，内存都应该重置为0。</p>

			<p>即使在同一个文本中，如果你移动到下一个句子，文本的主题发生了变化，新的主题出现了新的性别，那么你可能要忘记前一个主题的性别，准备加入新的主题，并相应地调整相应的词性。</p>

			<h3>输入门</h3>

			<p>输入门的目标更简单:它保存新的有用的输入信息。这里，同样，一个sigmoid门让输入分量完全通过(<img src="img/Formula_B16391_06_096.png" alt=""/>)，完全阻挡它们(<img src="img/Formula_B16391_06_097.png" alt=""/>)，或者介于两者之间，这取决于它们对最终、当前和未来输出的重要性。</p>

			<p>该决定再次执行如下:</p>

			<p><img src="img/Formula_B16391_06_098.png" alt=""/></p>

			<p>这是用一套新的砝码完成的，当然是<img src="img/Formula_B16391_06_099.png" alt=""/>。</p>

			<p>输入门不直接对先前的单元状态<img src="img/Formula_B16391_06_100.png" alt=""/>进行操作。相反，使用双曲正切层，基于当前输入向量<img src="img/Formula_B16391_06_102.png" alt=""/>和前一单元的输出向量<img src="img/Formula_B16391_06_103.png" alt=""/>中的值，创建新的单元<a id="_idIndexMarker501"/>候选状态<img src="img/Formula_B16391_06_101.png" alt=""/>。</p>

			<p>这看起来如下:</p>

			<p><img src="img/Formula_B16391_06_104.png" alt=""/></p>

			<p>同样，这是另一组权重，<img src="img/Formula_B16391_06_105.png" alt=""/>。</p>

			<p>输入门现在决定单元候选状态向量<img src="img/Formula_B16391_06_106.png" alt=""/>的哪个信息应该被添加到单元状态向量<img src="img/Formula_B16391_06_107.png" alt=""/>中。因此，将候选状态<img src="img/Formula_B16391_06_108.png" alt=""/>逐点乘以输入门<img src="img/Formula_B16391_06_109.png" alt=""/>的sigmoid层的输出，然后添加到过滤后的单元状态向量<img src="img/Formula_B16391_06_110.png" alt=""/>，最终状态<img src="img/Formula_B16391_06_111.png" alt=""/>，然后<a id="_idIndexMarker502"/>产生以下结果:</p>

			<p class="figure-caption"><img src="img/Formula_B16391_06_112.png" alt=""/></p>

			<p>我们在这里做了什么？我们已经向先前的单元状态向量<img src="img/Formula_B16391_06_113.png" alt=""/>添加了新的内容。假设我们想看课文中的一个新句子，其中<img src="img/Formula_B16391_06_114.png" alt=""/>是一个不同性别的主语。在遗忘门中，我们忘记了先前存储在细胞状态向量中的性别。现在，我们需要填补空白，将新的性别推入记忆——也就是说，推入新的细胞状态向量。</p>

			<h3>输出门</h3>

			<p>最后是输出门！我们有<a id="_idIndexMarker503"/>新的单元状态，<img src="img/Formula_B16391_06_115.png" alt=""/>，要传递给单元的下一个副本；我们只需要为当前时间输出一些东西。</p>

			<p>同样，像所有其他门一样，输出门将sigmoid函数应用于输入向量<img src="img/Formula_B16391_06_117.png" alt=""/>和先前输出向量<img src="img/Formula_B16391_06_118.png" alt=""/>的所有分量，以便决定从新创建的状态向量<img src="img/Formula_B16391_06_119.png" alt=""/>到最终输出向量<img src="img/Formula_B16391_06_120.png" alt=""/>中阻止什么和传递什么。然后，所有决策<img src="img/Formula_B16391_06_121.png" alt=""/>逐点乘以新创建的状态向量<img src="img/Formula_B16391_06_122.png" alt=""/>，先前通过<img src="img/Formula_B16391_06_123.png" alt=""/>函数归一化以落入<img src="img/Formula_B16391_06_124.png" alt=""/>:</p>

			<p><img src="img/Formula_B16391_06_125.png" alt=""/></p>

			<p><img src="img/Formula_B16391_06_126.png" alt=""/></p>

			<p>这是该输出门的一组新权重<img src="img/Formula_B16391_06_127.png" alt=""/>。</p>

			<p>在这种情况下，由LSTM递归单元<a id="_idIndexMarker504"/>产生的输出向量<img src="img/Formula_B16391_06_128.png" alt=""/>和状态向量<img src="img/Formula_B16391_06_129.png" alt=""/>是不同的，<img src="img/Formula_B16391_06_130.png" alt=""/>是<img src="img/Formula_B16391_06_131.png" alt=""/>的滤波版本。</p>

			<p>为什么我们需要不同于晶胞状态的输出？有时候输出需要和内存不同。例如，虽然细胞状态应该将性别的记忆带到下一个单元副本，但输出可能需要产生主体的数量，复数或单数，而不是其性别。</p>

			<p>LSTM层是一种非常强大的循环架构，能够保留大量先前输入的记忆。因此，这些层适合——并且经常用于解决——涉及有序数据序列的问题。如果有序的数据序列是基于时间排序的，那么我们就称之为时间序列。事实上，基于LSTM的RNNs已经成功地应用于时间序列分析问题。时间序列分析中要解决的一个经典任务是需求预测。在下一节中，我们将探索应用基于LSTM的神经网络来解决需求预测问题。</p>

			<h1 id="_idParaDest-106"><a id="_idTextAnchor192"/>需求预测问题</h1>

			<p>让我们继续探索一个需求预测问题<a id="_idIndexMarker505"/>以及如何将它作为一个时间序列分析问题来处理。</p>

			<p>需求预测是一项与对未来做出估计的需求相关的任务。我们都同意知道未来会发生什么会让生活变得容易得多。对于生活事件来说是如此，例如，洗衣机和冰箱的价格，或者整个城市的电能需求。了解顾客明天或下周想要多少瓶橄榄油，可以让零售店制定更好的进货计划。知道对汽油或柴油的需求可能会增加，可以让卡车运输公司更好地规划其财务。有无数的例子表明，这种对未来的了解是有帮助的。</p>

			<h2 id="_idParaDest-107"><a id="_idTextAnchor193"/>需求预测</h2>

			<p><strong class="bold">需求预测</strong>，或<a id="_idIndexMarker507"/>需求预测，是数据科学的一大分支。其目标是利用历史数据和其他可能的外部信息对未来需求进行估计。需求预测可以指任何种类的数字:餐馆的游客、发电量、学校新注册人数、啤酒瓶、尿布包、家用电器、时尚服装和配饰等等。需求预测可用于生产计划、库存管理，有时还可用于评估未来的产能需求，或决定是否进入新市场。</p>

			<p>需求预测技术通常基于时间序列分析。给定产品、货物或服务的先前需求值被存储并随时间排序以形成时间序列。当时间序列中的过去值被用来预测同一时间序列中的未来值时，我们说的是自回归分析技术。当来自其他外部时间序列的过去值也被用于预测时间序列中的未来值时，那么我们就在谈论多元回归分析技术。</p>

			<p><strong class="bold">时间序列分析</strong>是数据科学的一个<a id="_idIndexMarker508"/>领域，有很多传统，因为它已经提供了广泛的经典技术。传统的预测技术源于统计学，其顶级技术见于<a id="_idIndexMarker509"/><strong class="bold">自回归综合移动平均</strong> ( <strong class="bold"> ARIMA </strong>)模型及其变体。这些技术需要大量的统计假设，很难验证，并且通常不现实。另一方面，他们满足于相对少量的过去数据。</p>

			<p>最近，随着<strong class="bold">机器学习</strong>算法的日益流行，一些基于数据的回归技术也被应用于需求预测问题。这些机器学习技术的优点包括缺少所需的统计假设和数据转换的开销较少。缺点是需要大量的数据。此外，请注意，在时间序列的情况下，所有需要的统计假设都得到验证，传统方法往往表现更好。</p>

			<p>让我们试着根据过去的<img src="img/Formula_B16391_06_133.png" alt=""/>值来预测时间序列中的下一个<img src="img/Formula_B16391_06_132.png" alt=""/>值。当使用机器学习模型进行时间序列分析时，例如线性回归或回归树，我们需要提供过去的<img src="img/Formula_B16391_06_021.png" alt=""/>样本的向量作为<a id="_idIndexMarker510"/>输入，以训练模型预测下一个<img src="img/Formula_B16391_06_132.png" alt=""/>值。虽然这种策略通常被实施并产生令人满意的结果，但它仍然是一种静态的时间序列分析方法—<strong class="bold">static</strong>,因为每个输出响应仅取决于相应的输入向量。模型输入样本的呈现顺序不影响响应。没有输入序列的概念，只有输入向量的概念。</p>

			<p class="callout-heading">小费</p>

			<p class="callout">KNIME分析平台提供了一些节点和标准组件来处理时间序列分析。这里的关键节点是后台的<code>statsmodels</code> Python模块中的<code>EXAMPLES/00_Components/Time Series</code>文件夹。因此，它们需要安装KNIME Python集成(<a href="https://www.knime.com/blog/setting-up-the-knime-python-extension-revisited-for-python-30-and-20">https://www . KNIME . com/blog/setting-up-the-KNIME-Python-extension-revisited-for-Python-30-and-20</a>)。</p>

			<p>在<em class="italic">图6.6 </em>中，您可以看到KNIME Analytics平台中时间序列分析任务的可用组件列表:</p>

			<div><div><img src="img/B16391_06_006.jpg" alt="Figure 6.6 – The EXAMPLES/00_Components/Time Series folder contains components dedicated to time series analysis"/>

				</div>

			</div>

			<p class="figure-caption">图6.6–EXAMPLES/00 _<a id="_idTextAnchor194"/>Components/Time Series文件夹包含专用于时间序列分析的组件</p>

			<p>总的来说，这些使用回归模型的<a id="_idIndexMarker512"/>基于机器学习的策略没有充分利用数据的顺序结构，其中<img src="img/Formula_B16391_06_136.png" alt=""/>在<img src="img/Formula_B16391_06_137.png" alt=""/>之后的事实携带了一些额外的信息。这就是RNNs，尤其是LSTMs，可能在其他机器学习算法上提供优势的地方，这要归功于它们的内部<strong class="bold">内存</strong>。</p>

			<p>现在让我们介绍本章的案例研究:预测每小时所需的能源需求，单位为<strong class="bold">千瓦</strong> ( <strong class="bold">千瓦</strong>)。</p>

			<h2 id="_idParaDest-108"><a id="_idTextAnchor195"/>预测能源需求</h2>

			<p>作为需求预测的一个例子，我们想解决电能预测的问题——也就是说，预测一个普通家庭消费者在下一个小时需要多少千瓦。</p>

			<p>能源行业最困难的问题之一是供需匹配。一方面，过度生产能源会浪费资源；另一方面，生产不足会使人们没有现代生活的基本商品。因此，预测每个时间点的电能需求是数据科学中一个非常重要的课题。</p>

			<p>出于这个原因，几年前能源公司开始通过智能电表监控每个家庭、商店或其他实体的用电量。2009年，爱尔兰能源监管委员会(CER)启动了一个试点项目。</p>

			<p>智能计量电力<strong class="bold">客户行为试验</strong> ( <strong class="bold"> CBTs </strong>)在2009年至2010年间进行，有<a id="_idIndexMarker515"/>5000多个爱尔兰家庭和企业参与。试验的目的是评估对消费者电力消耗的影响，以便为全国推广的成本效益分析提供信息。参与试验的Electric Ireland住宅和企业客户以及Bord Gáis能源企业客户在其家中或其场所安装了智能电表，并同意参与研究，以帮助确定智能电表如何帮助塑造各种人口统计、生活方式和家庭规模的能源使用行为。</p>

			<p>原始数据集包含超过5000个时间序列，每个时间序列测量每个安装的智能电表一年多一点的用电量。所有原始时间序列都已调整和标准化，以报告每小时的能源计量。</p>

			<p>最终目标是预测所有用户的能源需求。在这一点上，我们有一个两难的问题:我们应该为每个时间序列训练一个模型，并对所有预测求和，以获得下一个小时的需求，还是应该为所有时间序列训练一个模型，以获得下一个小时的全局需求？</p>

			<p>在单个时间序列上训练一个模型<a id="_idIndexMarker516"/>更容易，也可能更准确。然而，训练5000个模型(在现实生活中可能更多)会带来一些技术问题。在所有时间序列上训练一个单一模型可能没有那么准确。正如预期的那样，实现了一个折衷的解决方案。智能电能表已根据能源使用情况进行了分组，并计算了每个分组的每小时能源使用量的平均时间序列。现在的目标是计算每个聚类时间序列在下一个小时的能量需求，根据聚类大小对其进行加权，然后对所有贡献进行求和，以找到下一个小时的最终总能量需求。</p>

			<p>根据工作日与周末在24小时内不同时间使用的能源以及每小时的平均消耗量，检测了30个智能仪表群。</p>

			<p>关于这个数据准备过程的更多细节可以在<em class="italic"> Data Chef ETL Battles中找到。用今天的数据可以准备什么？成分主题:能源消耗时间序列</em>博客文章，可在https://www.knime.com/blog/EnergyConsumptionTimeSeries,获得，并在<em class="italic">大数据、智能能源和预测分析</em>白皮书中获得，可在<a href="https://files.knime.com/sites/default/files/inline-images/knime_bigdata_energy_timeseries_whitepaper.pdf">https://files . knime . com/sites/default/files/inline-images/knime _ Big Data _ Energy _ Time Series _ white paper . pdf</a>获得。</p>

			<p>最终数据集包含30个集群平均能源使用的30个时间序列。每个时间序列显示了给定智能电表集群的电力配置:从商店(工作日上午9点到下午5点的高能耗)到夜间商业客户(每天晚上9点到6点的高能耗)，从家庭住户(每个工作日上午7点到9点的高能耗，然后下午6点到晚上10点的高能耗)到其他不明确的实体(一周7天24小时的能源使用)。例如，分类26表示商店(<em class="italic">图6.7 </em>)。在这里，电能主要在所有工作日的上午9点到下午5点之间使用:</p>

			<div><div><img src="img/B16391_06_007.jpg" alt="Figure 6.7 – Plot of energy usage by the hour for cluster 26"/>

				</div>

			</div>

			<p class="figure-caption">图6.7–集群26每小时的能源使用寿命图</p>

			<p>另一方面，集群13包括许多餐馆(<em class="italic">图6.8 </em>)，这些餐馆的能源使用<a id="_idIndexMarker517"/>被推到晚上，主要是从下午6点到午夜，一周的每一天:</p>

			<div><div><img src="img/B16391_06_008.jpg" alt="Figure 6.8 – Plot of energy usage by the hour for cluster 13"/>

				</div>

			</div>

			<p class="figure-caption">图6.8–集群13每小时的能源使用寿命图</p>

			<p>请注意，分类26是时间序列分析的典型代表，在一天24小时和一周7天的序列中具有明显的季节性。在这一章中，我们将继续对星团26的时间序列进行自回归分析。目标将是基于过去<img src="img/Formula_B16391_06_138.png" alt=""/>小时的平均能量使用<a id="_idIndexMarker518"/>来预测集群26在下一小时的平均能量使用。</p>

			<p>现在我们有了一组描述用户群每小时电能使用情况的时间序列，我们将尝试对每个用户群的未来使用情况进行一些预测。我们先来关注一下这个时间序列问题的数据准备。</p>

			<h1 id="_idParaDest-109"><a id="_idTextAnchor198"/>数据准备–创造过去</h1>

			<p>现在让我们在<a id="_idIndexMarker519"/>练习中实现一个需求预测应用程序，使用集群26的时间序列。同样，我们将有两个独立的工作流:一个用于培训位于LSTM的RNN，另一个用于在生产中部署它。两个应用程序都将包括数据准备阶段，这两个阶段必须完全相同。在本节中，我们将经历这个数据准备阶段。</p>

			<p>处理<strong class="bold">时间序列</strong>时，<strong class="bold">数据准备</strong>步骤与其他分类或聚类应用中实施的步骤略有不同。让我们来完成这些步骤:</p>

			<ul>

				<li><strong class="bold">数据加载</strong>:从文件中读取被识别的30个集群的平均每小时用电量的时间序列及其对应的时间。</li>

				<li><strong class="bold">日期和时间标准化</strong>:时间通常从文件中以字符串形式读取。为了确保它得到适当的处理，最好的做法是将其转换成一个<strong class="bold"> Date &amp; Time </strong>对象。有许多节点可以用来以一种适当而简单的方式处理日期时间对象，尤其是以一种标准化的方式。</li>

				<li><strong class="bold">时间戳对齐</strong>:一旦加载了时间序列，我们需要确保它的采样没有时间漏洞。可能的时间漏洞需要用丢失的值来填充。我们还需要确保时间序列的数据已经按时间排序。</li>

				<li><strong class="bold">分区</strong>:在这里，我们<a id="_idIndexMarker520"/>需要创建一个训练集来训练网络，以及一个测试集来评估它的性能。与分类问题不同，这里我们需要尊重时间顺序，以免将时间序列的过去和未来混在同一个集合中。应该为训练集保留过去的样本，为测试集保留未来的样本。</li>

				<li><strong class="bold">缺失值插补</strong>:时间序列的缺失值插补也不同于静态数据集中的缺失值插补。由于后一项取决于前一项，大多数时间序列缺失值插补技术都是基于前一项和/或后一项样本值。</li>

				<li><strong class="bold">创建过去样本的输入向量</strong>:一旦时间序列准备好进行分析，我们就需要构建张量来为网络提供信息。张量必须由<img src="img/Formula_B16391_06_021.png" alt=""/>过去的样本组成，网络将使用这些样本及时预测下一个样本的值。因此，我们需要为所有的训练和测试记录生成<img src="img/Formula_B16391_03_173.png" alt=""/>过去<img src="img/Formula_B16391_06_141.png" alt=""/>维度向量的序列(<img src="img/Formula_B16391_06_142.png" alt=""/>过去样本)。</li>

				<li><strong class="bold">创建列表以馈入网络</strong>:最后，必须将过去样本的输入张量转换为值列表，因为这是<a id="_idIndexMarker521"/>网络所需的输入格式。</li>

			</ul>

			<p>让我们从数据加载开始。</p>

			<h2 id="_idParaDest-110"><a id="_idTextAnchor199"/>数据加载和标准化</h2>

			<p>数据集通过<strong class="bold">文件阅读器</strong>节点从<strong class="bold"> CSV </strong>文件中读取:30个时间序列和一个日期列。日期列由文件读取器节点作为字符串导入，并且必须被<a id="_idIndexMarker522"/>转换成日期&amp;时间对象，以确保它在接下来的步骤中得到适当的处理——例如，排序。<strong class="bold">日期&amp;时间</strong>是表示KNIME分析平台中日期和时间实体的内部<a id="_idIndexMarker523"/>标准对象。为了将一个字符串转换成日期&amp;时间对象，我们使用<strong class="bold">字符串来表示日期&amp;时间</strong>节点:</p>

			<div><div><img src="img/B16391_06_009.jpg" alt="Figure 6.9 – The String to Date&amp;Time node and its configuration window"/>

				</div>

			</div>

			<p class="figure-caption">图6.9–到目前为止的字符串&amp;Tim <a id="_idTextAnchor200"/> e节点及其配置窗口</p>

			<p>在配置窗口(<em class="italic">图6.9 </em>，您必须选择包含日期和/或时间信息的字符串输入栏，并定义日期/时间格式。您可以通过提供一个字符串格式来手动完成这项工作——例如，<code>dd.mm.yyyy</code>表示日，<code>mm</code>表示月，<code>yyyy</code>表示年。</p>

			<p>例如，如果您有<code>day(2).month(2).year(4)</code>的<a id="_idIndexMarker524"/>日期格式，您可以手动添加选项<code>dd.MM.yyyy</code>，如果在<strong class="bold">日期格式</strong>选项中<a id="_idIndexMarker525"/>没有此项。手动添加日期/时间类型时，必须选择合适的<strong class="bold">新类型</strong>选项:<strong class="bold">日期或时间</strong>或<strong class="bold">日期&amp;时间</strong>。</p>

			<p>或者，您可以按下<strong class="bold">猜测数据类型和格式</strong>按钮，自动提供日期/时间格式。使用最后一个选项，KNIME Analytics Platform将解析您的字符串，找出日期/时间格式。大部分时间都管用！如果没有，您可以随时恢复到手动输入日期/时间格式。</p>

			<p class="callout-heading">小费</p>

			<p class="callout">在<strong class="bold">字符串到数据&amp;时间</strong>节点的节点描述中，您可以找到格式结构中可能的占位符的概述。最重要的是代表年份的<strong class="bold"> y </strong>、代表一年中月份的<strong class="bold"> M </strong>、代表一月中某日的<strong class="bold"> d </strong>、代表一天中某小时的<strong class="bold">H</strong>(0到23之间)、代表一小时中某分钟的<strong class="bold"> m </strong>以及代表一分钟中某秒钟的<strong class="bold"> s </strong>。支持更多的占位符——例如，<strong class="bold"> W </strong>表示一个月中的某周，或者<strong class="bold"> D </strong>表示一年中的某天。</p>

			<p>“日期和时间字符串”节点只是处理日期和时间对象的众多节点之一，所有节点都包含在<strong class="bold">节点库</strong>面板的<strong class="bold">其他数据类型/时间序列</strong>文件夹中。一些节点操纵日期&amp;时间对象，例如，计算时差或产生时间偏移；其他节点用于将日期&amp;时间对象从一种格式转换为另一种格式。</p>

			<p>之后，插入列过滤器节点，只隔离集群26的时间序列。这里唯一需要的标准化是关于从字符串到日期和时间对象的日期转换。我们现在可以继续进行数据清理了。</p>

			<h2 id="_idParaDest-111"><a id="_idTextAnchor201"/>数据清理和分区</h2>

			<p>插入<strong class="bold">时间戳对齐</strong>组件<a id="_idIndexMarker526"/>来检查时间序列中的时间漏洞。该组件检查所选的<a id="_idIndexMarker527"/>时间戳列是否在所选的时间<a id="_idIndexMarker528"/>标度内被均匀采样。缺失值将在跳过的采样时间插入。在这种情况下，它检查包含时间戳的<strong class="bold"> rowID </strong>列是否在考虑每小时采样率的情况下丢失了采样时间。</p>

			<p>时间戳对齐组件是<code>EXAMPLES/00_Components/Time Series</code>中提供的时序专用组件集的一部分。要在工作流中创建实例，只需将其拖放到工作流编辑器中或双击它。</p>

			<p>之后，我们将数据分成训练集和测试集，对LSTM的RNN进行训练和评估。我们在此没有提供额外的验证集来评估整个培训过程中的网络性能。我们决定保持简单，只为Keras网络学习者节点提供一个训练集和一个测试集，以测量时间序列预测任务的误差:</p>

			<div><div><img src="img/B16391_06_010.jpg" alt="Figure 6.10 – The Partitioning node and its configuration window. Notice the Take from top data extraction mode for time series analysis"/>

				</div>

			</div>

			<p class="figure-caption">图6.10–分区节点及其配置窗口。请注意用于时间序列分析的top数据提取模式</p>

			<p>为了将输入数据集<a id="_idIndexMarker529"/>分成训练集和测试集，我们再次使用了<strong class="bold">分区</strong>节点。这里，我们<a id="_idIndexMarker530"/>决定实现80%–20%的分割:80%的输入数据将用于训练，20%用于测试。此外，我们将提取程序设置为<strong class="bold">从顶部提取</strong> ( <em class="italic">图6.10 </em>)。在一个时间序列分析问题中，我们希望保持数据的内在时间顺序:我们用过去来训练网络，用未来来检验网络。当使用<strong class="bold">从顶部提取</strong>数据提取选项时，顶部百分比的数据被指定到顶部输出端口，而底部剩余的数据被指定到下部输出端口。如果数据是从过去到未来按时间排序的，那么这种数据提取方式会保留数据的时间顺序。</p>

			<p class="callout-heading">重要说明</p>

			<p class="callout">在时间序列分析问题中，分区应该使用<strong class="bold">自顶向下</strong>的数据提取模式，以便保留数据的时间顺序，并使用过去的数据进行训练，使用未来的数据进行测试。</p>

			<p>对于每一个数据集，缺失值填补操作都是一个重要的操作；首先，因为神经网络无法处理缺失值，其次，因为选择正确的缺失值插补技术会影响最终结果。</p>

			<p class="callout-heading">重要说明</p>

			<p class="callout">缺失值插补必须在时间戳对齐组件之后实施，因为根据定义，该组件会产生缺失值。</p>

			<p>在<a href="B16391_04_Final_NM_ePUB.xhtml#_idTextAnchor101"> <em class="italic">第四章</em></a><em class="italic">构建和训练前馈网络</em>中，我们已经介绍了<strong class="bold">缺失值</strong>节点及其不同的缺失值估算策略。当涉及到<a id="_idIndexMarker532"/>顺序数据时，这些策略中的一些特别有用，因为它们考虑了时间序列中的前一个和/或后一个值。可能的策略如下:</p>

			<ul>

				<li><strong class="bold">平均/线性插值</strong>，用上一个和下一个样本的平均值替换缺失值</li>

				<li><strong class="bold">移动平均值</strong>，用样本窗口的平均值替换缺失值</li>

				<li><strong class="bold">下一个</strong>，用下一个样本的值替换缺失值</li>

				<li><strong class="bold">前一个</strong>，用前一个样本的值替换缺失的值</li>

			</ul>

			<p>我们使用前一个值和下一个值之间的线性插值来估算时间序列中的缺失值(<em class="italic">图6.11 </em>):</p>

			<p class="figure-caption"><a id="_idTextAnchor203"/></p>

			<div><div><img src="img/B16391_06_011.jpg" alt="Figure 6.11 – The Missing Value node and its configuration window"/>

				</div>

			</div>

			<p class="figure-caption">图6.11–缺失值节点及其配置窗口</p>

			<p>用于<a id="_idIndexMarker533"/>缺失值插补的公式在训练数据的<strong class="bold">缺失值</strong>节点中计算，通过<strong class="bold">缺失值(应用)</strong>节点应用于测试数据，并通过模型编写器节点保存到文件中。在训练集上定义的公式的测试集上的<a id="_idIndexMarker534"/>纯应用防止测试数据干扰模型训练所需的任何转换的实现。</p>

			<p>接下来让我们关注神经网络的输入张量的创建。</p>

			<h2 id="_idParaDest-112"><a id="_idTextAnchor204"/>创建输入张量</h2>

			<p>我们已经读取了<a id="_idIndexMarker535"/>数据，将日期单元格转换为日期&amp;时间对象，分离出聚类26的时间序列，将缺失值分配给缺失的采样步骤，将数据分成80%用于训练集，20%用于测试集，在缺失值插补的前一个值和下一个值之间应用线性插值。数据准备好了，现在是为神经网络创建输入张量的时候了。</p>

			<p class="callout-heading">重要说明</p>

			<p class="callout">创建过去样本向量的一个关键节点是滞后列节点，这在时间序列分析中是经常需要的。</p>

			<p><em class="italic">图6.12 </em>显示了<a id="_idIndexMarker536"/>滞后列节点及其配置窗口<a id="_idTextAnchor205"/> w:</p>

			<div><div><img src="img/B16391_06_012.jpg" alt="Figure 6.12 – The Lag Column node and its configuration window"/>

				</div>

			</div>

			<p class="figure-caption">图6.12–滞后列节点及其配置窗口</p>

			<p><strong class="bold">滞后列</strong>节点复制所选列，并将其下移<img src="img/Formula_B16391_06_143.png" alt=""/>个单元格，其中<img src="img/Formula_B16391_06_144.png" alt=""/>个单元格，其中<img src="img/Formula_B16391_06_145.png" alt=""/>是滞后间隔，<img src="img/Formula_B16391_06_146.png" alt=""/>是配置窗口中的<strong class="bold">滞后</strong>设置。</p>

			<p>滞后列节点<a id="_idIndexMarker537"/>是一个非常简单但非常强大的节点，在很多情况下都很方便。如果输入列是按时间排序的，那么下移单元格相当于将它们移到过去或未来，这取决于时间顺序。</p>

			<p>在<em class="italic">图6.13 </em>中，我们解释了这个概念:</p>

			<div><div><img src="img/B16391_06_013.jpg" alt="Figure 6.13 – The Lag Column node takes snapshots of the same column at different times, as defined by the Lag and Lag interval settings"/>

				</div>

			</div>

			<p class="figure-caption">图6.13–滞后列节点在不同时间拍摄同一列的快照，如滞后和滞后间隔设置所定义</p>

			<p>考虑到滞后= 4和滞后间隔= 2，滞后列节点产生选定列的四个副本，每个副本向后移动2步。也就是说，除了在当前时间<em class="italic"> t </em>选择的列之外，我们还将拥有同一列在时间<em class="italic"> t </em> -2、<em class="italic"> t </em> -4、<em class="italic"> t </em> -6、<em class="italic"> t </em> -8 ( <em class="italic">图6.13 </em>)的四个快照。</p>

			<p>对于我们的需求预测问题，我们使用集群26在最近200小时内使用的平均能量值来预测当前小时的平均能量需求。也就是说，我们使用滞后=200且滞后间隔=1的滞后列节点，用200个刚刚过去的样本构建输入向量(<em class="italic">图6.12 </em>)。</p>

			<p>出于空间原因，我们随后使用<strong class="bold">列聚合器</strong>节点将细胞向量转换为细胞集合，因为这是通过Keras网络学习器节点向神经网络提供信息的可能格式之一。列聚合器节点是<a id="_idIndexMarker538"/>产生<strong class="bold">数据单元格列表</strong>的另一种方式。该节点对每行的选定列进行分组，并使用选定的聚合方法聚合它们的单元格。在这种情况下，选择<strong class="bold">列表</strong>聚集方法，并将其应用于通过滞后列节点创建的群集26的200个过去值。</p>

			<p>实现数据准备部分为即将到来的需求预测问题提供RNN的工作流片段如图<em class="italic">图6.14 </em>所示:</p>

			<div><div><img src="img/B16391_06_014.jpg" alt="Figure 6.14 – Data preparation for demand prediction: date and time standardization, time alignment, missing value imputation, creating the input vector of past samples, and partitioning"/>

				</div>

			</div>

			<p class="figure-caption">图<a id="_idTextAnchor207"/>ure 6.14–需求预测的数据准备:日期和时间标准化、时间校准、缺失值插补、创建过去样本的输入向量以及分区</p>

			<p>数据准备好了。现在，让我们构建、训练和测试基于LSTM的RNN，以在给定同一集群26在前200小时中使用的平均能量的情况下，预测集群26在当前小时的平均电能需求。</p>

			<h1 id="_idParaDest-113"><a id="_idTextAnchor208"/>建立、训练和部署LSTM RNN</h1>

			<p>让我们进行下一步:构建一个简单的基于LSTM的需求预测RNN。首先，我们将训练网络，然后我们将测试它，最后，我们将部署它。在本案例研究中，我们没有为网络使用验证集，也没有对网络的静态超参数(例如，LSTM层的大小)进行优化。</p>

			<p>一个相对简单的网络已经在我们的需求预测任务的测试集上实现了良好的误差测量，因此，我们决定将本节的重点放在如何测试时间序列预测的模型，而不是如何优化神经网络的静态参数。我们在<a href="B16391_05_Final_NM_ePUB.xhtml#_idTextAnchor152"> <em class="italic">第5章</em> </a>、<em class="italic">欺诈检测自动编码器</em>中查看了优化循环。一般来说，这个优化循环也可以应用于优化网络超参数。让我们从建立一个基于LSTM的RNN开始。</p>

			<h2 id="_idParaDest-114"><a id="_idTextAnchor209"/>打造LSTM RNN</h2>

			<p>在这个案例研究中，我们选择了最简单的基于LSTM的RNN:只有一个隐藏LSTM层的RNN。因此，最终网络由以下部分组成:</p>

			<ul>

				<li>一个输入层接受200个过去向量的张量-每个过去向量都是前一个样本，即大小为1-通过Shape = 200，1的Keras输入层节点获得。</li>

				<li>一个具有100个LSTM单位的隐藏层，通过<strong class="bold"> Keras LSTM层</strong>节点接受之前的张量作为唯一输入</li>

				<li>作为输出的经典密集层，只有一个神经元产生时间序列中下一个样本的预测值，该预测值通过具有ReLU激活函数的Keras密集层节点获得。</li>

			</ul>

			<p>用于构建该神经架构的节点如图<em class="italic">图6.15 </em>所示:</p>

			<div><div><img src="img/B16391_06_015.jpg" alt="Figure 6.15 – Building a very basic, very simple LSTM-based RNN"/>

				</div>

			</div>

			<p class="figure-caption">图6.15–建造一个非常基本、非常简单的LSTM RNN</p>

			<p class="callout-heading">重要说明</p>

			<p class="callout">输入张量的大小是[200，1]，它是200个1大小的向量的序列。如果输入序列的长度未知，我们可以使用<em class="italic">？</em>表示未知序列长度。下一章的NLP案例研究将向你展示一些这样的例子。</p>

			<p>我们已经在前面的章节中描述了Keras输入层节点和Keras密集层节点。让我们探索，在这一节，只是喀拉斯LSTM层节点。</p>

			<p class="callout-heading">重要说明</p>

			<p class="callout">到目前为止，当我们谈到输入、单元状态和输出时，我们一直使用术语向量。张量是一种更一般化的形式，代表一个沿着k维延伸的向量。秩0张量等于标量值，秩1张量等于向量，秩2张量等于矩阵。</p>

			<p>注意，Keras LSTM层节点最多接受三个输入张量:一个输入序列的输入值，两个初始化隐藏状态张量，<img src="img/Formula_B16391_06_147.png" alt=""/>和<img src="img/Formula_B16391_06_148.png" alt=""/>。</p>

			<p>如果前一个神经层产生多个张量作为输出，在当前LSTM层的配置窗口中，通过下拉菜单，您可以选择哪个张量应该用作输入或初始化隐藏状态。</p>

			<p>我们将在下一章探索更复杂的神经结构。这里，我们将我们的架构限制在最简单的经典LSTM层配置，只接受来自输入层的一个输入张量。在<em class="italic">图6.16 </em>的LSTM层节点的配置窗口中可以看到作为输入接受的一个输入张量<a id="_idIndexMarker541"/>:</p>

			<div><div><img src="img/B16391_06_016.jpg" alt="Figure 6.16 – The Keras LSTM Layer node and its configuration window"/>

				</div>

			</div>

			<p class="figure-caption">图<a id="_idTextAnchor211"/>6.16-Keras LSTM层节点及其配置窗口</p>

			<p>对于LSTM层，我们可以设置两个激活函数，称为<strong class="bold">激活</strong>和<strong class="bold">循环激活</strong>。门使用<strong class="bold">循环激活</strong>功能来过滤输入<a id="_idIndexMarker542"/>组件。选择为<strong class="bold">激活</strong>的功能用于创建单元状态<img src="img/Formula_B16391_06_149.png" alt=""/>的候选项，并在应用输出门之前归一化新的单元状态<img src="img/Formula_B16391_06_150.png" alt=""/>。这意味着，对于我们在本章中介绍的标准LSTM单元，激活<strong class="bold">的设置是双曲正切函数，循环激活<strong class="bold">的设置是sigmoid函数。</strong></strong></p>

			<p>我们设置层来增加LSTM单位的不同层的偏差，但决定不使用下降。</p>

			<p><strong class="bold">实现</strong>和<strong class="bold">展开</strong>设置选项对结果没有任何影响，但可以提高性能，具体取决于您的硬件和序列长度。当激活<strong class="bold">展开</strong>复选框时，网络会在训练前展开，这样可以加快学习过程，但是占用内存大，只适合短输入序列。如果未选中，在TensorFlow后端会使用一个所谓的符号<a id="_idIndexMarker543"/>循环。</p>

			<p>您可以选择是将中间输出张量<img src="img/Formula_B16391_06_151.png" alt=""/>作为完整序列返回，还是仅返回最后一个输出张量<img src="img/Formula_B16391_06_152.png" alt=""/>(<strong class="bold">返回序列</strong>选项)。此外，还可以输出隐藏的单元格状态张量作为输出(<strong class="bold">返回状态</strong>选项)。在能源需求预测案例研究中，仅使用LSTM单元的最终输出张量来为下一个密集层提供ReLU激活函数。因此，这两个复选框没有被激活。</p>

			<p>“节点配置”窗口中的其他三个选项卡设置正则化项、初始化策略和学习算法的约束。我们在这一层没有设置任何规则和约束。让我们训练这个网络。</p>

			<h2 id="_idParaDest-115"><a id="_idTextAnchor212"/>培训LSTM的RNN</h2>

			<p>Keras网络<a id="_idIndexMarker544"/>学习者节点随后在训练集上训练这个位于LSTM的RNN。我们已经知道了这个节点。让我们总结一下本案例研究的配置窗口中使用的规格:</p>

			<ul>

				<li>接受输入张量，并从数字(双精度)集合转换为<strong class="bold">。</strong></li>

				<li>通过转换成<strong class="bold">数字(双精度)</strong>产生输出向量。</li>

				<li>在<strong class="bold">目标</strong>选项卡中，损失函数被设置为<strong class="bold">均方误差</strong> ( <strong class="bold"> MSE </strong>)。</li>

				<li>在<strong class="bold">选项</strong>选项卡中，历元数设置为<code>50</code>，训练批量设置为<code>256</code>，训练算法设置为<strong class="bold">亚当</strong>——反向传播的优化版本。</li>

				<li>学习率被设置为<code>0.001</code>，没有学习率衰减。</li>

			</ul>

			<p>对于在输出层中只有一个神经元的这个网络，训练批次上的MSE损失函数采用更简单的形式，并且变成如下:</p>

			<p><img src="img/Formula_B16391_06_153.png" alt=""/></p>

			<p>这里，<img src="img/Formula_B16391_06_154.png" alt=""/>是<a id="_idIndexMarker545"/>批量，<img src="img/Formula_B16391_06_155.png" alt=""/>是训练样本<img src="img/Formula_B16391_06_156.png" alt=""/>的输出值，<img src="img/Formula_B16391_06_157.png" alt=""/>是对应的目标答案。</p>

			<p>由于我们将数字预测和MSE作为损失函数进行讨论，因此<strong class="bold">学习监视器</strong>视图的<strong class="bold">损失</strong>选项卡中的图是评估学习过程时要考虑的图。因为我们试图预测精确的数字，所以在这种情况下准确性没有意义。<em class="italic">图6.17 </em>显示了针对该需求预测示例的Keras网络学习者节点的<strong class="bold">学习监视器</strong>视图:</p>

			<div><div><img src="img/B16391_06_017.jpg" alt="Figure 6.17 – Plot of the MSE loss function over training epochs in the Loss tab of &#13;&#10;the Learning Monitor view"/>

				</div>

			</div>

			<p class="figure-caption">图6.17-学习监视器视图的loss选项卡中MSE损失函数在训练时期的曲线图</p>

			<p><em class="italic">图6.17 </em>中的截图显示，经过几次批量训练迭代后，我们<a id="_idIndexMarker546"/>达到了可接受的预测误差，至少在训练集上是如此。训练后，应使用<strong class="bold"> Keras网络执行器</strong>节点将网络应用于测试集，并使用<strong class="bold"> Keras网络编写器</strong>节点将其保存为Keras文件进行部署。</p>

			<p>现在让我们将训练好的LSTM网络应用于测试集。</p>

			<h2 id="_idParaDest-116"><a id="_idTextAnchor214"/>测试LSTM RNN</h2>

			<p>理论上，要测试网络的性能，我们只需将网络应用于测试集中的输入张量。这很容易用一个<strong class="bold"> Keras网络执行器</strong>节点来完成。</p>

			<p><em class="italic">图6.18 </em>显示了<strong class="bold">样品内测试</strong>组件的内部:</p>

			<div><div><img src="img/B16391_06_018.jpg" alt="Figure 6.18 – Inside of the In-sample testing component"/>

				</div>

			</div>

			<p class="figure-caption">图6.18-样品内测试组件的Insid <a id="_idTextAnchor215"/> e</p>

			<p>样本内测试<a id="_idIndexMarker548"/>组件选择要测试的输入序列的数量(<strong class="bold">行过滤器</strong>节点)，然后将它们通过<strong class="bold"> Keras网络执行器</strong>节点，并将预测与相应的目标答案相结合。</p>

			<p>之后，在<strong class="bold">样本内测试</strong>组件之外，<strong class="bold">数字计分器</strong>节点计算一些误差指标，并且<strong class="bold">线图(Plotly) </strong>节点显示原始时间序列和重构的时间序列(最终工作流程见<em class="italic">图</em> <em class="italic"> 6.25 </em>)。数字误差指标量化了误差，而折线图直观地展示了预测的可信度。用这种方法生成的预测称为<strong class="bold">样本内</strong>预测。</p>

			<p>数值计分器节点<a id="_idIndexMarker549"/>计算六个误差度量(<em class="italic">图6.19 </em> ): R2、<strong class="bold">平均绝对误差</strong> ( <strong class="bold"> MAE </strong>)、MSE、<strong class="bold">均方根误差</strong> ( <strong class="bold"> RMSE </strong>)、<strong class="bold">平均有符号差</strong> ( <strong class="bold"> MSD </strong>)、<strong class="bold">平均绝对百分比误差</strong> ( <strong class="bold"> MAPE </strong>)。相应的公式如下所示:</p>

			<div><div><img src="img/Formula_B16391_06_158.jpg" alt=""/>

				</div>

			</div>

			<div><div><img src="img/Formula_B16391_06_159.jpg" alt=""/>

				</div>

			</div>

			<div><div><img src="img/Formula_B16391_06_160.jpg" alt=""/>

				</div>

			</div>

			<div><div><img src="img/Formula_B16391_06_161.jpg" alt=""/>

				</div>

			</div>

			<div><div><img src="img/Formula_B16391_06_162.jpg" alt=""/>

				</div>

			</div>

			<div><div><img src="img/Formula_B16391_06_163.jpg" alt=""/>

				</div>

			</div>

			<p>这里，<img src="img/Formula_B16391_06_164.png" alt=""/>是来自测试集的<a id="_idIndexMarker550"/>预测数，<img src="img/Formula_B16391_06_165.png" alt=""/>是测试样本<img src="img/Formula_B16391_06_166.png" alt=""/>的输出值，<img src="img/Formula_B16391_06_167.png" alt=""/>是相应的目标答案。我们选择在600个张量的测试集上应用网络，生成相应的预测，并计算误差度量。这是我们得到的结果:</p>

			<div><div><img src="img/B16391_06_019.jpg" alt="Figure 6.19 – Error measures between in-sample predicted 600 values and the corresponding target values"/>

				</div>

			</div>

			<p class="figure-caption">图6.19–样本内预测600值和相应目标值之间的误差测量</p>

			<p>每个指标都有其优点和缺点。时间序列预测通常采用的误差是MAPE、平均误差或均方误差。例如，MAPE在<a id="_idIndexMarker551"/>预测时间序列的下600个值上显示只有9%的误差，这是一个非常好的结果。<em class="italic">图6.20 </em>中的曲线证明了这一点:</p>

			<div><div><img src="img/B16391_06_020.jpg" alt=""/>

				</div>

			</div>

			<p class="figure-caption">图6.20–时间序列中下一个600英寸<a id="_idTextAnchor217"/>的充足预测值与下一个600目标值的对比</p>

			<p>这是一个简单的测试。对于每个要预测的值，我们将真实值的先前历史输入网络。这是一种奢侈的情况，我们不能总是负担得起。通常，我们只根据过去的预测值，一个接一个地预测接下来的600个值。也就是说，一旦我们训练了网络，我们就用测试集中的前200个真实的过去值来触发下一个预测。然而，在这之后，我们基于最新的199个真实值加上当前预测的值来预测下一个值；然后再次基于最新的198个实际值加上先前预测的值和当前预测的值，等等。这是一种次优但更现实的情况。用这种方法生成的预测称为<strong class="bold">样本外</strong>预测<a id="_idIndexMarker552"/>，这种测试称为样本外测试。</p>

			<p>为了实现样本外测试，我们需要实现将当前预测反馈到过去样本向量中的循环。这个循环也已经在部署工作流中实现了。让我们来看看这个实现的细节。</p>

			<h2 id="_idParaDest-117"><a id="_idTextAnchor218"/>构建部署循环</h2>

			<p>为了实现<a id="_idIndexMarker553"/>样本外测试，我们需要实现上一节描述的循环，其中当前预测值成为下一次预测的过去值的张量的一部分。这是在名为<strong class="bold">部署循环</strong> ( <em class="italic">图6.21 </em>)的组件中完成的，该组件也在最终工作流中的出样测试组件内(<em class="italic">图6.25 </em>):</p>

			<div><div><img src="img/B16391_06_021.jpg" alt="Figure 6.21 – The deployment loop. Notice the recursive loop to pass back &#13;&#10;the new input sequence at each iteration"/>

				</div>

			</div>

			<p class="figure-caption">图6.21–部署l <a id="_idTextAnchor219"/> oop。注意递归循环在每次迭代中都传回新的输入序列</p>

			<p>这里，一个<code>no_preds</code>，在<code>no_preds=600</code>中创建)。</p>

			<p>整数配置节点属于一组特殊的配置节点，因此它的配置窗口转移到包含它的组件的配置窗口中。因此，<strong class="bold">部署循环</strong>组件有一个配置设置，用于使用递归循环创建预测的数量，如图<em class="italic">图6.22 </em>所示:</p>

			<div><div><img src="img/B16391_06_022.jpg" alt="Figure 6.22 – The configuration window of the Deployment Loop component"/>

				</div>

			</div>

			<p class="figure-caption">F <a id="_idTextAnchor220"/>图6.22–展开回路组件的配置窗口</p>

			<p class="callout-heading">重要说明</p>

			<p class="callout">递归循环是KNIME Analytics平台中为数不多的循环之一，它允许您将结果传递回去，供下一次迭代使用。</p>

			<p><strong class="bold">部署循环</strong>组件使用<a id="_idIndexMarker557"/>两个新的重要节点:</p>

			<ul>

				<li><strong class="bold">Keras到TensorFlow网络转换器节点</strong>:Keras到TensorFlow转换器节点将带有TensorFlow后端的Keras深度学习模型转换为TensorFlow模型。TensorFlow模型使用TensorFlow Java API执行，它通常比通过Keras Python API提供的Python内核更快。如果我们在递归循环中使用Keras网络执行器节点，那么每次迭代都必须启动一个Python内核，这会降低网络执行速度。张量流模型使网络执行速度更快。</li>

				<li><strong class="bold">TensorFlow网络执行器节点</strong>:tensor flow网络执行器节点的配置窗口类似于Keras网络执行器节点的配置窗口，唯一的区别是后端引擎，在本例中是tensor flow。</li>

			</ul>

			<p>对于样本外测试，部署循环由测试集中的第一个张量触发，并从那里自动生成600个预测。在样本外测试组件中，这些预测将与目标值相结合，在样本外测试组件之外，数值误差节点将计算选定的误差指标。</p>

			<p>显然，对于样本外<a id="_idIndexMarker558"/>测试，误差值变得更大(<em class="italic">图6.23 </em>)，因为预测误差受到前面步骤中预测误差的影响。例如，MAPE达到18%，几乎是样品测试结果的两倍:</p>

			<div><div><img src="img/B16391_06_023.jpg" alt="Figure 6.23 – Error measures between the out-sample predicted 600 values and &#13;&#10;the corresponding target values"/>

				</div>

			</div>

			<p class="figure-caption"><a id="_idTextAnchor221"/>图6.23–样本外预测600值和相应目标值之间的误差测量</p>

			<p>在<em class="italic">图6.24 </em>中，我们可以看到可视化预测时间序列并将其与前600个样本外预测的原始时间序列进行比较时的预测误差:</p>

			<div><div><img src="img/B16391_06_024.jpg" alt="Figure 6.24 – The next 600 out-sample predicted values (orange) against the next 600 target values (blue) in the time series"/>

				</div>

			</div>

			<p class="figure-caption">F <a id="_idTextAnchor222"/> <a id="_idTextAnchor223"/>图6.24–时间序列中接下来的600个样本外预测值(橙色)与接下来的600个目标值(蓝色)</p>

			<p>在那里，我们可以看到第一个预测是非常正确的，但是随着我们远离测试集的开始，它们开始恶化。当然，样本内预测不存在这种效应。事实上，第一次样本外预测的误差值与相应的样本内预测的误差值相当。</p>

			<p>我们在这里进行了一个<a id="_idIndexMarker559"/>非常粗略的时间序列预测，因为我们没有将季节性预测作为一个单独的问题来考虑。我们以某种方式让网络自己管理整个预测，而不分离季节性和残差。对于这个用例，我们的结果是令人满意的。然而，对于更复杂的用例，可以计算季节性指数，减去季节性，然后只对时间序列的残值进行预测。希望这将是一个更简单的问题，并导致更准确的预测。然而，我们对预测误差感到满意，特别是考虑到网络还必须管理季节性的预测。</p>

			<p>最终的工作流程，构建、训练和样本内测试网络，如图<em class="italic">图6.25 </em>所示:</p>

			<div><div><img src="img/B16391_06_025.jpg" alt="Figure 6.25 – The final workflow to prepare the data and build, train, and test the LSTM-based network on a time series prediction problem"/>

				</div>

			</div>

			<p class="figure-caption">图6.25-准备数据以及建立、训练和测试基于时间序列预测问题的LSTM网络的最终工作流程</p>

			<p>这个工作流程可以在本书的GitHub空间中找到。现在让我们转到部署工作流。</p>

			<h2 id="_idParaDest-118"><a id="_idTextAnchor226"/>部署位于LSTM的RNN</h2>

			<p>此时部署很容易。例如，我们从一个<code>.table</code>文件中读取部署数据；然后，我们应用与训练和测试数据相同的数据准备步骤。我们用200个过去的样本分离第一个输入序列；我们应用部署循环来生成<img src="img/Formula_B16391_06_168.png" alt=""/>新样本(这里，我们使用<img src="img/Formula_B16391_06_169.png" alt=""/>)；我们在部署循环中应用训练有素的LSTM RNN；最后，我们用一个线图(Plotly)节点来可视化预测。请注意，这一次没有相对于目标值的预测，因为部署数据是真实世界的数据，而不是实验室数据，因此没有任何目标值可以比较。</p>

			<p>部署工作流程如图<em class="italic">图6.26 </em>所示，可在KNIME Hub上获得，网址为<a href="https://hub.knime.com/kathrin/spaces/Codeless%20Deep%20Learning%20with%20KNIME/latest/Chapter%206/">https://Hub . KNIME . com/kath rin/spaces/Codeless % 20 deep % 20 learning % 20 with % 20 KNIME/latest/Chapter % 206/</a>:</p>

			<div><div><img src="img/B16391_06_026.jpg" alt="Figure 6.26 – The deployment workflow for a demand prediction problem"/>

				</div>

			</div>

			<p class="figure-caption">图6.26–需求预测问题的部署工作流程</p>

			<p>这是<a id="_idIndexMarker562"/>部署工作流，包括数据读取、与训练工作流中的数据相同的数据准备、网络读取和生成预测的部署循环。</p>

			<p>在最后一节中，我们学习了如何将部署循环应用于部署工作流，以在现实生活中生成新的预测。</p>

			<h1 id="_idParaDest-119"><a id="_idTextAnchor228"/>总结</h1>

			<p>在这一章中，我们介绍了一个新的递归神经单元:LSTM单元。我们展示了它是如何构建和训练的，以及它如何应用于时间序列分析问题，如需求预测。</p>

			<p>作为需求预测问题的一个例子，我们试图预测一群用户在下一个小时消耗的平均能量，给定前200个小时使用的能量。我们展示了如何测试样本内和样本外预测，以及一些常用于量化预测误差的数值度量。应用于能源消耗的需求预测只是众多需求预测用例之一。这里学到的相同方法可以应用于预测餐馆中的顾客数量、网站的访问者数量或超市中某类食品的需求量。</p>

			<p>在本章中，我们还介绍了KNIME Analytics平台中的一个新循环，即递归循环，并且我们提到了一个新的可视化节点，即线图(Plotly)节点。</p>

			<p>在下一章中，我们将继续学习RNNs，关注不同的文本相关的应用。</p>

			<h1 id="_idParaDest-120"><a id="_idTextAnchor229"/>问题和练习</h1>

			<p>通过回答以下问题，检查您对本章所探讨概念的理解程度:</p>

			<ol>

				<li>Why are LSTM units suitable for time series analysis?<p>a)。因为它们比传统的前馈网络更快</p><p>b)。因为它们能记住过去的输入张量</p><p>c)。因为他们使用大门</p><p>d)。因为它们有隐藏状态</p></li>

				<li>What is the data extraction option to use for partitioning in time series analysis?<p>a)。随机抽取</p><p>b)。从头开始</p><p>c)。分层抽样</p><p>d)。线性抽样</p></li>

				<li>What is a tensor?<p>a)。张量是一个二维向量。</p><p>b)。张量是一个k维T2矢量。</p><p>c)。张量只是一个数字。</p><p>d)。张量是一系列数字。</p></li>

				<li>What is the difference between in-sample and out-sample testing?<p>a)。样本内测试使用测试集中真实的过去值来进行预测。样本外测试使用过去的预测值来进行新的预测。</p><p>b)。样本内测试比样本外测试更现实。</p><p>c)。样本内测试比样本外测试更复杂。</p><p>d)。样本内测试应用训练好的网络，而样本外测试使用规则。</p></li>

			</ol>

		</div>

	



</body></html>